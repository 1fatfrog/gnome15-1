diff --git a/drivers/hid/Kconfig b/drivers/hid/Kconfig
index 4340993..e0e7089 100644
--- a/drivers/hid/Kconfig
+++ b/drivers/hid/Kconfig
@@ -230,6 +230,64 @@ config HID_MAGICMOUSE
 	Say Y here if you want support for the multi-touch features of the
 	Apple Wireless "Magic" Mouse.
 
+config HID_LOGITECH_G13
+	tristate "Logitech G13 gameboard support"
+	depends on FB
+	depends on FB_DEFERRED_IO
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_SYS_FOPS
+	select HID_LOGITECH_GFB
+	help
+	  This provides support for Logitech G13 gameboard
+	  devices. This includes support for the device
+	  as a keypad input with mappable keys as well as
+	  a framebuffer for the LCD display.
+
+config HID_LOGITECH_G15
+	tristate "Logitech G15 gameboard support"
+	depends on FB
+	depends on FB_DEFERRED_IO
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_SYS_FOPS
+	select HID_LOGITECH_GFB
+	help
+	  This provides support for Logitech G15 gameboard
+	  devices. This includes support for the device
+	  as a keypad input with mappable keys as well as
+	  a framebuffer for the LCD display.
+
+config HID_LOGITECH_G19
+	tristate "Logitech G19 gameboard support"
+	depends on FB
+	depends on FB_DEFERRED_IO
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_SYS_FOPS
+	select HID_LOGITECH_GFB
+	help
+	  This provides support for Logitech G19 gameboard
+	  devices. This includes support for the device
+	  as a keypad input with mappable keys as well as
+	  a framebuffer for the LCD display.
+
+config HID_LOGITECH_GFB
+	tristate "Logitech G series framebuffer support"
+	depends on FB
+	depends on FB_DEFERRED_IO
+	select FB_SYS_FILLRECT
+	select FB_SYS_COPYAREA
+	select FB_SYS_IMAGEBLIT
+	select FB_SYS_FOPS
+	help
+	  This provides support for Logitech G series gameboard
+	  devices. This module provides a common panel driver
+	  for various Logitech devices.
+
 config HID_MICROSOFT
 	tristate "Microsoft" if EMBEDDED
 	depends on USB_HID
diff --git a/drivers/hid/Makefile b/drivers/hid/Makefile
index 987fa06..5d10904 100644
--- a/drivers/hid/Makefile
+++ b/drivers/hid/Makefile
@@ -37,6 +37,10 @@ obj-$(CONFIG_HID_GYRATION)	+= hid-gyration.o
 obj-$(CONFIG_HID_KENSINGTON)	+= hid-kensington.o
 obj-$(CONFIG_HID_KYE)		+= hid-kye.o
 obj-$(CONFIG_HID_LOGITECH)	+= hid-logitech.o
+obj-$(CONFIG_HID_LOGITECH_G13)	+= hid-g13.o
+obj-$(CONFIG_HID_LOGITECH_G15)  += hid-g15.o
+obj-$(CONFIG_HID_LOGITECH_G19)  += hid-g19.o
+obj-$(CONFIG_HID_LOGITECH_GFB)  += hid-gfb.o
 obj-$(CONFIG_HID_MAGICMOUSE)    += hid-magicmouse.o
 obj-$(CONFIG_HID_MICROSOFT)	+= hid-microsoft.o
 obj-$(CONFIG_HID_MONTEREY)	+= hid-monterey.o
diff --git a/drivers/hid/hid-core.c b/drivers/hid/hid-core.c
index 866e54e..a7465c8 100644
--- a/drivers/hid/hid-core.c
+++ b/drivers/hid/hid-core.c
@@ -1326,6 +1326,9 @@ static const struct hid_device_id hid_blacklist[] = {
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_MOMO_WHEEL2) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G25_WHEEL) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_RUMBLEPAD2) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G13) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G15_LCD) },
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G19_LCD) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_SPACETRAVELLER) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_SPACENAVIGATOR) },
 	{ HID_USB_DEVICE(USB_VENDOR_ID_MICROCHIP, USB_DEVICE_ID_PICOLCD) },
diff --git a/drivers/hid/hid-g13.c b/drivers/hid/hid-g13.c
new file mode 100644
index 0000000..f431473
--- /dev/null
+++ b/drivers/hid/hid-g13.c
@@ -0,0 +1,1360 @@
+/***************************************************************************
+ *   Copyright (C) 2009 by Rick L. Vinyard, Jr.                            *
+ *   rvinyard@cs.nmsu.edu                                                  *
+ *                                                                         *
+ *   This program is free software: you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation, either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This driver is distributed in the hope that it will be useful, but    *
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU      *
+ *   General Public License for more details.                              *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this software. If not see <http://www.gnu.org/licenses/>.  *
+ ***************************************************************************/
+#include <linux/fb.h>
+#include <linux/hid.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/mm.h>
+#include <linux/sysfs.h>
+#include <linux/uaccess.h>
+#include <linux/usb.h>
+#include <linux/vmalloc.h>
+#include <linux/leds.h>
+#include <linux/completion.h>
+
+#include "hid-ids.h"
+#include "usbhid/usbhid.h"
+
+#include "hid-gfb.h"
+
+#define G13_NAME "Logitech G13"
+
+/* Key defines */
+#define G13_KEYS 35
+#define G13_KEYMAP_SIZE (G13_KEYS*3)
+
+/* Framebuffer defines */
+#define G13FB_NAME "g13fb"
+#define G13FB_WIDTH (160)
+#define G13FB_LINE_LENGTH (160/8)
+#define G13FB_HEIGHT (43)
+#define G13FB_SIZE (G13FB_LINE_LENGTH*G13FB_HEIGHT)
+
+#define G13FB_UPDATE_RATE_LIMIT (20)
+#define G13FB_UPDATE_RATE_DEFAULT (10)
+
+/*
+ * The native G13 format uses vertical bits. Therefore the number of bytes
+ * needed to represent the first column is 43/8 (rows/bits) rounded up.
+ * Additionally, the format requires a padding of 32 bits in front of the
+ * image data.
+ *
+ * Therefore the vbitmap size must be:
+ *   160 * ceil(43/8) + 32 = 160 * 6 + 32 = 992
+ */
+#define G13_VBITMAP_SIZE (992)
+
+/* Backlight defaults */
+#define G13_DEFAULT_RED (0)
+#define G13_DEFAULT_GREEN (255)
+#define G13_DEFAULT_BLUE (0)
+
+/* LED array indices */
+#define G13_LED_M1 0
+#define G13_LED_M2 1
+#define G13_LED_M3 2
+#define G13_LED_MR 3
+
+#define G13_REPORT_4_INIT	0x00
+#define G13_REPORT_4_FINALIZE	0x01
+
+#define G13_READY_SUBSTAGE_1 0x01
+#define G13_READY_SUBSTAGE_2 0x02
+#define G13_READY_SUBSTAGE_3 0x04
+#define G13_READY_STAGE_1    0x07
+#define G13_READY_SUBSTAGE_4 0x08
+#define G13_READY_SUBSTAGE_5 0x10
+#define G13_READY_STAGE_2    0x1F
+#define G13_READY_SUBSTAGE_6 0x20
+#define G13_READY_SUBSTAGE_7 0x40
+#define G13_READY_STAGE_3    0x7F
+
+#define G13_RESET_POST 0x01
+#define G13_RESET_MESSAGE_1 0x02
+#define G13_RESET_READY 0x03
+
+/* Per device data structure */
+struct g13_data {
+	/* HID reports */
+	struct hid_device *hdev;
+	struct hid_report *backlight_report;
+	struct hid_report *start_input_report;
+	struct hid_report *feature_report_4;
+	struct hid_report *led_report;
+	struct hid_report *output_report_3;
+	struct input_dev *input_dev;
+
+	/* core state */
+	char *name;
+	int keycode[G13_KEYMAP_SIZE];
+	int scancode_state[G13_KEYS];
+	u8 rgb[3];
+	u8 led;
+	u8 curkeymap;
+	u8 keymap_switching;
+
+	/* Framebuffer stuff */
+	struct gfb_data *gfb_data;
+
+	/* LED stuff */
+	struct led_classdev *led_cdev[4];
+
+	/* Housekeeping stuff */
+	spinlock_t lock;
+	struct completion ready;
+	int ready_stages;
+	int need_reset;
+};
+
+/* Convenience macros */
+#define hid_get_g13data(hdev) \
+	((struct g13_data *)(hid_get_drvdata(hdev)))
+
+#define input_get_hdev(idev) \
+	((struct hid_device *)(input_get_drvdata(idev)))
+
+#define input_get_g13data(idev) (hid_get_g13data(input_get_hdev(idev)))
+
+/*
+ * Keymap array indices
+ *
+ * Key        Index
+ * ---------  ------
+ * G1-G22     0-21
+ * FUNC       22
+ * LCD1       23
+ * LCD2       24
+ * LCD3       25
+ * LCD4       26
+ * M1         27
+ * M2         28
+ * M3         29
+ * MR         30
+ * BTN_LEFT   31
+ * BTN_DOWN   32
+ * BTN_STICK  33
+ * LIGHT      34
+ */
+static const unsigned int g13_default_key_map[G13_KEYS] = {
+/* first row g1 - g7 */
+KEY_F1, KEY_F2, KEY_F3, KEY_F4, KEY_F5, KEY_F6, KEY_F7,
+/* second row g8 - g11 */
+KEY_UNKNOWN, KEY_UNKNOWN, KEY_BACK, KEY_UP,
+/* second row g12 - g13 */
+KEY_FORWARD, KEY_UNKNOWN, KEY_UNKNOWN,
+/* third row g15 - g19 */
+KEY_UNKNOWN, KEY_LEFT, KEY_DOWN, KEY_RIGHT, KEY_UNKNOWN,
+/* fourth row g20 - g22 */
+KEY_BACKSPACE, KEY_ENTER, KEY_SPACE,
+/* next, light left, light center left, light center right, light right */
+BTN_0, BTN_1, BTN_2, BTN_3, BTN_4,
+/* M1, M2, M3, MR */
+KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,
+/* button left, button down, button stick, light */
+BTN_LEFT, BTN_RIGHT, BTN_MIDDLE, KEY_RESERVED,
+};
+
+
+static DEVICE_ATTR(fb_node, 0444, gfb_fb_node_show, NULL);
+static DEVICE_ATTR(fb_update_rate, 0666,
+		   gfb_fb_update_rate_show,
+		   gfb_fb_update_rate_store);
+
+
+static void g13_led_send(struct hid_device *hdev)
+{
+	struct g13_data *data = hid_get_g13data(hdev);
+
+	data->led_report->field[0]->value[0] = data->led&0x0F;
+	data->led_report->field[0]->value[1] = 0x00;
+	data->led_report->field[0]->value[2] = 0x00;
+	data->led_report->field[0]->value[3] = 0x00;
+
+	usbhid_submit_report(hdev, data->led_report, USB_DIR_OUT);
+}
+
+static void g13_led_set(struct led_classdev *led_cdev,
+			 enum led_brightness value,
+			 int led_num)
+{
+	struct device *dev;
+	struct hid_device *hdev;
+	struct g13_data *data;
+	u8 mask;
+
+	/* Get the device associated with the led */
+	dev = led_cdev->dev->parent;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* Get the underlying data value */
+	data = hid_get_g13data(hdev);
+
+	mask = 0x01<<led_num;
+	if (value)
+		data->led |= mask;
+	else
+		data->led &= ~mask;
+
+	g13_led_send(hdev);
+}
+
+static void g13_led_m1_brightness_set(struct led_classdev *led_cdev,
+				      enum led_brightness value)
+{
+	g13_led_set(led_cdev, value, G13_LED_M1);
+}
+
+static void g13_led_m2_brightness_set(struct led_classdev *led_cdev,
+				      enum led_brightness value)
+{
+	g13_led_set(led_cdev, value, G13_LED_M2);
+}
+
+static void g13_led_m3_brightness_set(struct led_classdev *led_cdev,
+				      enum led_brightness value)
+{
+	g13_led_set(led_cdev, value, G13_LED_M3);
+}
+
+static void g13_led_mr_brightness_set(struct led_classdev *led_cdev,
+				      enum led_brightness value)
+{
+	g13_led_set(led_cdev, value, G13_LED_MR);
+}
+
+static enum led_brightness g13_led_brightness_get(struct led_classdev *led_cdev)
+{
+	struct device *dev;
+	struct hid_device *hdev;
+	struct g13_data *data;
+	int value = 0;
+
+	/* Get the device associated with the led */
+	dev = led_cdev->dev->parent;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* Get the underlying data value */
+	data = hid_get_g13data(hdev);
+
+	if (led_cdev == data->led_cdev[G13_LED_M1])
+		value = data->led & 0x01;
+	else if (led_cdev == data->led_cdev[G13_LED_M2])
+		value = data->led & 0x02;
+	else if (led_cdev == data->led_cdev[G13_LED_M3])
+		value = data->led & 0x04;
+	else if (led_cdev == data->led_cdev[G13_LED_MR])
+		value = data->led & 0x08;
+	else
+		dev_info(dev, G13_NAME " error retrieving LED brightness\n");
+
+	if (value)
+		return LED_FULL;
+	return LED_OFF;
+}
+
+static const struct led_classdev g13_led_cdevs[4] = {
+	{
+		.brightness_set		= g13_led_m1_brightness_set,
+		.brightness_get		= g13_led_brightness_get,
+	},
+	{
+		.brightness_set		= g13_led_m2_brightness_set,
+		.brightness_get		= g13_led_brightness_get,
+	},
+	{
+		.brightness_set		= g13_led_m3_brightness_set,
+		.brightness_get		= g13_led_brightness_get,
+	},
+	{
+		.brightness_set		= g13_led_mr_brightness_set,
+		.brightness_get		= g13_led_brightness_get,
+	},
+};
+
+static int g13_input_setkeycode(struct input_dev *dev,
+				int scancode,
+				int keycode)
+{
+	int old_keycode;
+	int i;
+	struct g13_data *data = input_get_g13data(dev);
+
+	if (scancode >= dev->keycodemax)
+		return -EINVAL;
+
+	spin_lock(&data->lock);
+
+	old_keycode = data->keycode[scancode];
+	data->keycode[scancode] = keycode;
+
+	__clear_bit(old_keycode, dev->keybit);
+	__set_bit(keycode, dev->keybit);
+
+	for (i = 0; i < dev->keycodemax; i++) {
+		if (data->keycode[i] == old_keycode) {
+			__set_bit(old_keycode, dev->keybit);
+			break; /* Setting the bit twice is useless, so break*/
+		}
+	}
+
+	spin_unlock(&data->lock);
+
+	return 0;
+}
+
+static int g13_input_getkeycode(struct input_dev *dev,
+				int scancode,
+				int *keycode)
+{
+	struct g13_data *data = input_get_g13data(dev);
+
+	if (!dev->keycodesize)
+		return -EINVAL;
+
+	if (scancode >= dev->keycodemax)
+		return -EINVAL;
+
+	*keycode = data->keycode[scancode];
+
+	return 0;
+}
+
+
+/*
+ * The "keymap" attribute
+ */
+static ssize_t g13_keymap_index_show(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct g13_data *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", data->curkeymap);
+}
+
+static ssize_t g13_set_keymap_index(struct hid_device *hdev, unsigned k)
+{
+	int scancode;
+	int offset_old;
+	int offset_new;
+	int keycode_old;
+	int keycode_new;
+	struct g13_data *data = hid_get_g13data(hdev);
+	struct input_dev *idev = data->input_dev;
+
+	if (k > 2)
+		return -EINVAL;
+
+	/*
+	 * Release all the pressed keys unless the new keymap has the same key
+	 * in the same scancode position.
+	 *
+	 * Also, clear the scancode state unless the new keymap has the same
+	 * key in the same scancode position.
+	 *
+	 * This allows a keycode mapped to the same scancode in two different
+	 * keymaps to remain pressed without a key up code when the keymap is
+	 * switched.
+	 */
+	offset_old = G13_KEYS * data->curkeymap;
+	offset_new = G13_KEYS * k;
+	for (scancode = 0; scancode < G13_KEYS; scancode++) {
+		keycode_old = data->keycode[offset_old+scancode];
+		keycode_new = data->keycode[offset_new+scancode];
+		if (keycode_old != keycode_new) {
+			if (keycode_old != KEY_RESERVED)
+				input_report_key(idev, keycode_old, 0);
+			data->scancode_state[scancode] = 0;
+		}
+	}
+
+	data->curkeymap = k;
+
+	if (data->keymap_switching) {
+		data->led = 1 << k;
+		g13_led_send(hdev);
+	}
+
+	return 0;
+}
+
+static ssize_t g13_keymap_index_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct hid_device *hdev;
+	int i;
+	unsigned k;
+	ssize_t set_result;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* If we have an invalid pointer we'll return ENODATA */
+	if (hdev == NULL || &(hdev->dev) != dev)
+		return -ENODATA;
+
+	i = sscanf(buf, "%u", &k);
+	if (i != 1) {
+		dev_warn(dev, G13_NAME " unrecognized input: %s", buf);
+		return -1;
+	}
+
+	set_result = g13_set_keymap_index(hdev, k);
+
+	if (set_result < 0)
+		return set_result;
+
+	return count;
+}
+
+static DEVICE_ATTR(keymap_index, 0666,
+		   g13_keymap_index_show,
+		   g13_keymap_index_store);
+
+/*
+ * The "keycode" attribute
+ */
+static ssize_t g13_keymap_show(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	int offset = 0;
+	int result;
+	int scancode;
+	int keycode;
+	int error;
+
+	struct g13_data *data = dev_get_drvdata(dev);
+
+	for (scancode = 0; scancode < G13_KEYMAP_SIZE; scancode++) {
+		error = input_get_keycode(data->input_dev, scancode, &keycode);
+		if (error) {
+			dev_warn(dev, G13_NAME " error accessing scancode %d\n",
+				 scancode);
+			continue;
+		}
+
+		result = sprintf(buf+offset, "0x%03x 0x%04x\n",
+				 scancode, keycode);
+		if (result < 0)
+			return -EINVAL;
+		offset += result;
+	}
+
+	return offset+1;
+}
+
+static ssize_t g13_keymap_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct hid_device *hdev;
+	int scanned;
+	int consumed;
+	int scancd;
+	int keycd;
+	int error;
+	int set = 0;
+	int gkey;
+	int index;
+	int good;
+	struct g13_data *data;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* If we have an invalid pointer we'll return ENODATA */
+	if (hdev == NULL || &(hdev->dev) != dev)
+		return -ENODATA;
+
+	/* Now, let's get the data structure */
+	data = hid_get_g13data(hdev);
+
+	do {
+		good = 0;
+
+		/* Look for scancode keycode pair in hex */
+		scanned = sscanf(buf, "%x %x%n", &scancd, &keycd, &consumed);
+		if (scanned == 2) {
+			buf += consumed;
+			error = g13_input_setkeycode(data->input_dev, scancd, keycd);
+			if (error)
+				goto err_input_setkeycode;
+			set++;
+			good = 1;
+		} else {
+			/*
+			 * Look for Gkey keycode pair and assign to current
+			 * keymap
+			 */
+			scanned = sscanf(buf, "G%d %x%n", &gkey, &keycd, &consumed);
+			if (scanned == 2 && gkey > 0 && gkey <= G13_KEYS) {
+				buf += consumed;
+				scancd = data->curkeymap * G13_KEYS + gkey - 1;
+				error = g13_input_setkeycode(data->input_dev, scancd, keycd);
+				if (error)
+					goto err_input_setkeycode;
+				set++;
+				good = 1;
+			} else {
+				/*
+				 * Look for Gkey-index keycode pair and assign
+				 * to indexed keymap
+				 */
+				scanned = sscanf(buf, "G%d-%d %x%n", &gkey, &index, &keycd, &consumed);
+				if (scanned == 3 &&
+				    gkey > 0 && gkey <= G13_KEYS &&
+				    index >= 0 && index <= 2) {
+					buf += consumed;
+					scancd = index * G13_KEYS + gkey - 1;
+					error = g13_input_setkeycode(data->input_dev, scancd, keycd);
+					if (error)
+						goto err_input_setkeycode;
+					set++;
+					good = 1;
+				}
+			}
+		}
+
+	} while (good);
+
+	if (set == 0) {
+		dev_warn(dev, G13_NAME " unrecognized keycode input: %s", buf);
+		return -1;
+	}
+
+	return count;
+
+err_input_setkeycode:
+	dev_warn(dev, G13_NAME " error setting scancode %d to keycode %d\n",
+		 scancd, keycd);
+	return error;
+}
+
+static DEVICE_ATTR(keymap, 0666, g13_keymap_show, g13_keymap_store);
+
+/*
+ * The "keymap_switching" attribute
+ */
+static ssize_t g13_keymap_switching_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct g13_data *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", data->keymap_switching);
+}
+
+static ssize_t g13_set_keymap_switching(struct hid_device *hdev, unsigned k)
+{
+	struct g13_data *data = hid_get_g13data(hdev);
+
+	data->keymap_switching = k;
+
+	if (data->keymap_switching) {
+		data->led = 1 << data->curkeymap;
+		g13_led_send(hdev);
+	}
+
+	return 0;
+}
+
+static ssize_t g13_keymap_switching_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct hid_device *hdev;
+	int i;
+	unsigned k;
+	ssize_t set_result;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* If we have an invalid pointer we'll return ENODATA */
+	if (hdev == NULL || &(hdev->dev) != dev)
+		return -ENODATA;
+
+	i = sscanf(buf, "%u", &k);
+	if (i != 1) {
+		dev_warn(dev, G13_NAME "unrecognized input: %s", buf);
+		return -1;
+	}
+
+	set_result = g13_set_keymap_switching(hdev, k);
+
+	if (set_result < 0)
+		return set_result;
+
+	return count;
+}
+
+static DEVICE_ATTR(keymap_switching, 0644,
+		   g13_keymap_switching_show,
+		   g13_keymap_switching_store);
+
+
+static ssize_t g13_name_show(struct device *dev,
+			     struct device_attribute *attr,
+			     char *buf)
+{
+	struct g13_data *data = dev_get_drvdata(dev);
+	int result;
+
+	if (data->name == NULL) {
+		buf[0] = 0x00;
+		return 1;
+	}
+
+	spin_lock(&data->lock);
+	result = sprintf(buf, "%s", data->name);
+	spin_unlock(&data->lock);
+
+	return result;
+}
+
+static ssize_t g13_name_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct g13_data *data = dev_get_drvdata(dev);
+	size_t limit = count;
+	char *end;
+
+	spin_lock(&data->lock);
+
+	if (data->name != NULL) {
+		kfree(data->name);
+		data->name = NULL;
+	}
+
+	end = strpbrk(buf, "\n\r");
+	if (end != NULL)
+		limit = end - buf;
+
+	if (end != buf) {
+
+		if (limit > 100)
+			limit = 100;
+
+		data->name = kzalloc(limit+1, GFP_ATOMIC);
+
+		strncpy(data->name, buf, limit);
+	}
+
+	spin_unlock(&data->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(name, 0666, g13_name_show, g13_name_store);
+
+static void g13_feature_report_4_send(struct hid_device *hdev, int which)
+{
+	struct g13_data *data = hid_get_g13data(hdev);
+
+	if (which == G13_REPORT_4_INIT) {
+		data->feature_report_4->field[0]->value[0] = 0x02;
+		data->feature_report_4->field[0]->value[1] = 0x00;
+		data->feature_report_4->field[0]->value[2] = 0x00;
+		data->feature_report_4->field[0]->value[3] = 0x00;
+	} else if (which == G13_REPORT_4_FINALIZE) {
+		data->feature_report_4->field[0]->value[0] = 0x02;
+		data->feature_report_4->field[0]->value[1] = 0x80;
+		data->feature_report_4->field[0]->value[2] = 0x00;
+		data->feature_report_4->field[0]->value[3] = 0xFF;
+	} else {
+		return;
+	}
+
+	usbhid_submit_report(hdev, data->feature_report_4, USB_DIR_OUT);
+}
+
+static void g13_rgb_send(struct hid_device *hdev)
+{
+	struct g13_data *data = hid_get_g13data(hdev);
+
+	data->backlight_report->field[0]->value[0] = data->rgb[0];
+	data->backlight_report->field[0]->value[1] = data->rgb[1];
+	data->backlight_report->field[0]->value[2] = data->rgb[2];
+	data->backlight_report->field[0]->value[3] = 0x00;
+
+	usbhid_submit_report(hdev, data->backlight_report, USB_DIR_OUT);
+}
+
+/*
+ * The "rgb" attribute
+ * red green blue
+ * each with values 0 - 255 (black - full intensity)
+ */
+static ssize_t g13_rgb_show(struct device *dev,
+			    struct device_attribute *attr,
+			    char *buf)
+{
+	unsigned r, g, b;
+	struct g13_data *data = dev_get_drvdata(dev);
+
+	r = data->rgb[0];
+	g = data->rgb[1];
+	b = data->rgb[2];
+
+	return sprintf(buf, "%u %u %u\n", r, g, b);
+}
+
+static void g13_rgb_set(struct hid_device *hdev,
+			unsigned r, unsigned g, unsigned b)
+{
+	struct g13_data *data = hid_get_g13data(hdev);
+
+	data->rgb[0] = r;
+	data->rgb[1] = g;
+	data->rgb[2] = b;
+
+	g13_rgb_send(hdev);
+}
+
+static ssize_t g13_rgb_store(struct device *dev,
+			     struct device_attribute *attr,
+			     const char *buf, size_t count)
+{
+	struct hid_device *hdev;
+	int i;
+	unsigned r;
+	unsigned g;
+	unsigned b;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* If we have an invalid pointer we'll return ENODATA */
+	if (hdev == NULL || &(hdev->dev) != dev)
+		return -ENODATA;
+
+	i = sscanf(buf, "%u %u %u", &r, &g, &b);
+	if (i != 3) {
+		dev_warn(dev, G13_NAME "unrecognized input: %s", buf);
+		return -1;
+	}
+
+	g13_rgb_set(hdev, r, g, b);
+
+	return count;
+}
+
+static DEVICE_ATTR(rgb, 0666, g13_rgb_show, g13_rgb_store);
+
+/*
+ * The "minor" attribute
+ */
+static ssize_t g13_minor_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	struct g13_data *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", data->hdev->minor);
+}
+
+static DEVICE_ATTR(minor, 0444, g13_minor_show, NULL);
+
+/*
+ * Create a group of attributes so that we can create and destroy them all
+ * at once.
+ */
+static struct attribute *g13_attrs[] = {
+	&dev_attr_name.attr,
+	&dev_attr_rgb.attr,
+	&dev_attr_keymap_index.attr,
+	&dev_attr_keymap_switching.attr,
+	&dev_attr_keymap.attr,
+	&dev_attr_minor.attr,
+	&dev_attr_fb_update_rate.attr,
+	&dev_attr_fb_node.attr,
+	NULL,	/* need to NULL terminate the list of attributes */
+};
+
+/*
+ * An unnamed attribute group will put all of the attributes directly in
+ * the kobject directory.  If we specify a name, a subdirectory will be
+ * created for the attributes with the directory being the name of the
+ * attribute group.
+ */
+static struct attribute_group g13_attr_group = {
+	.attrs = g13_attrs,
+};
+
+static void g13_handle_key_event(struct g13_data *data,
+				 struct input_dev *idev,
+				 int scancode,
+				 int value)
+{
+	int error;
+	int keycode;
+	int offset;
+
+	offset = G13_KEYS * data->curkeymap;
+
+	error = input_get_keycode(idev, scancode+offset, &keycode);
+
+	if (unlikely(error)) {
+		dev_warn(&idev->dev, G13_NAME " error in input_get_keycode(): scancode=%d\n", scancode);
+		return;
+	}
+
+	/* Only report mapped keys */
+	if (keycode != KEY_RESERVED)
+		input_report_key(idev, keycode, value);
+	/* Or report MSC_SCAN on keypress of an unmapped key */
+	else if (data->scancode_state[scancode] == 0 && value)
+		input_event(idev, EV_MSC, MSC_SCAN, scancode);
+
+	data->scancode_state[scancode] = value;
+}
+
+static void g13_raw_event_process_input(struct hid_device *hdev,
+					struct g13_data *data,
+					u8 *raw_data)
+{
+	struct input_dev *idev = data->input_dev;
+	int scancode;
+	int value;
+	int i;
+	int mask;
+
+	/*
+	 * We'll check for the M* keys being pressed before processing
+	 * the remainder of the key data. That way the new keymap will
+	 * be loaded if there is a keymap switch.
+	 */
+	if (unlikely(data->keymap_switching)) {
+		if (data->curkeymap != 0 && raw_data[6] & 0x20)
+			g13_set_keymap_index(hdev, 0);
+		else if (data->curkeymap != 1 && raw_data[6] & 0x40)
+			g13_set_keymap_index(hdev, 1);
+		else if (data->curkeymap != 2 && raw_data[6] & 0x80)
+			g13_set_keymap_index(hdev, 2);
+	}
+
+	for (i = 0, mask = 0x01; i < 8; i++, mask <<= 1) {
+		/* Keys G1 through G8 */
+		scancode = i;
+		value = raw_data[3] & mask;
+		g13_handle_key_event(data, idev, scancode, value);
+
+		/* Keys G9 through G16 */
+		scancode = i + 8;
+		value = raw_data[4] & mask;
+		g13_handle_key_event(data, idev, scancode, value);
+
+		/* Keys G17 through G22 */
+		scancode = i + 16;
+		value = raw_data[5] & mask;
+		if (i <= 5)
+			g13_handle_key_event(data, idev, scancode, value);
+
+		/* Keys FUNC through M3 */
+		scancode = i + 22;
+		value = raw_data[6] & mask;
+		g13_handle_key_event(data, idev, scancode, value);
+
+		/* Keys MR through LIGHT */
+		scancode = i + 30;
+		value = raw_data[7] & mask;
+		if (i <= 4)
+			g13_handle_key_event(data, idev, scancode, value);
+	}
+
+	input_report_abs(idev, ABS_X, raw_data[1]);
+	input_report_abs(idev, ABS_Y, raw_data[2]);
+	input_sync(idev);
+}
+
+static int g13_raw_event(struct hid_device *hdev,
+			 struct hid_report *report,
+			 u8 *raw_data, int size)
+{
+	/*
+	* On initialization receive a 258 byte message with
+	* data = 6 0 255 255 255 255 255 255 255 255 ...
+	*/
+	struct g13_data *data;
+	data = dev_get_drvdata(&hdev->dev);
+
+	spin_lock(&data->lock);
+
+	if (unlikely(data->need_reset)) {
+		g13_rgb_send(hdev);
+		g13_led_send(hdev);
+		data->need_reset = 0;
+		spin_unlock(&data->lock);
+		return 1;
+	}
+
+	if (unlikely(data->ready_stages != G13_READY_STAGE_3)) {
+		switch (report->id) {
+		case 6:
+			if (!(data->ready_stages & G13_READY_SUBSTAGE_1))
+				data->ready_stages |= G13_READY_SUBSTAGE_1;
+			else if (data->ready_stages & G13_READY_SUBSTAGE_4 &&
+				 !(data->ready_stages & G13_READY_SUBSTAGE_5)
+				)
+				data->ready_stages |= G13_READY_SUBSTAGE_5;
+			else if (data->ready_stages & G13_READY_SUBSTAGE_6 &&
+				 raw_data[1] >= 0x80)
+				data->ready_stages |= G13_READY_SUBSTAGE_7;
+			break;
+		case 1:
+			if (!(data->ready_stages & G13_READY_SUBSTAGE_2))
+				data->ready_stages |= G13_READY_SUBSTAGE_2;
+			else
+				data->ready_stages |= G13_READY_SUBSTAGE_3;
+			break;
+		}
+
+		if (data->ready_stages == G13_READY_STAGE_1 ||
+		    data->ready_stages == G13_READY_STAGE_2 ||
+		    data->ready_stages == G13_READY_STAGE_3)
+			complete_all(&data->ready);
+
+		spin_unlock(&data->lock);
+		return 1;
+	}
+
+	spin_unlock(&data->lock);
+
+	if (likely(report->id == 1)) {
+		g13_raw_event_process_input(hdev, data, raw_data);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void g13_initialize_keymap(struct g13_data *data)
+{
+	int i;
+
+	for (i = 0; i < G13_KEYS; i++) {
+		data->keycode[i] = g13_default_key_map[i];
+		__set_bit(data->keycode[i], data->input_dev->keybit);
+	}
+
+	__clear_bit(KEY_RESERVED, data->input_dev->keybit);
+}
+
+static int g13_probe(struct hid_device *hdev,
+		     const struct hid_device_id *id)
+{
+	int error;
+	struct g13_data *data;
+	int i;
+	int led_num;
+	struct usb_interface *intf;
+	struct usb_device *usbdev;
+	struct list_head *feature_report_list =
+		&hdev->report_enum[HID_FEATURE_REPORT].report_list;
+	struct list_head *output_report_list =
+			&hdev->report_enum[HID_OUTPUT_REPORT].report_list;
+	struct hid_report *report;
+	char *led_name;
+
+	dev_dbg(&hdev->dev, "Logitech G13 HID hardware probe...");
+
+	/* Get the usb device to send the start report on */
+	intf = to_usb_interface(hdev->dev.parent);
+	usbdev = interface_to_usbdev(intf);
+
+	/*
+	 * Let's allocate the g13 data structure, set some reasonable
+	 * defaults, and associate it with the device
+	 */
+	data = kzalloc(sizeof(struct g13_data), GFP_KERNEL);
+	if (data == NULL) {
+		dev_err(&hdev->dev, "can't allocate space for Logitech G13 device attributes\n");
+		error = -ENOMEM;
+		goto err_no_cleanup;
+	}
+
+	spin_lock_init(&data->lock);
+
+	init_completion(&data->ready);
+
+	data->hdev = hdev;
+
+	hid_set_drvdata(hdev, data);
+
+	dbg_hid("Preparing to parse " G13_NAME " hid reports\n");
+
+	/* Parse the device reports and start it up */
+	error = hid_parse(hdev);
+	if (error) {
+		dev_err(&hdev->dev, G13_NAME " device report parse failed\n");
+		error = -EINVAL;
+		goto err_cleanup_data;
+	}
+
+	error = hid_hw_start(hdev, HID_CONNECT_DEFAULT | HID_CONNECT_HIDINPUT_FORCE);
+	if (error) {
+		dev_err(&hdev->dev, G13_NAME " hardware start failed\n");
+		error = -EINVAL;
+		goto err_cleanup_data;
+	}
+
+	dbg_hid(G13_NAME " claimed: %d\n", hdev->claimed);
+
+	error = hdev->ll_driver->open(hdev);
+	if (error) {
+		dev_err(&hdev->dev, G13_NAME " failed to open input interrupt pipe for key and joystick events\n");
+		error = -EINVAL;
+		goto err_cleanup_data;
+	}
+
+	/* Set up the input device for the key I/O */
+	data->input_dev = input_allocate_device();
+	if (data->input_dev == NULL) {
+		dev_err(&hdev->dev, G13_NAME " error initializing the input device");
+		error = -ENOMEM;
+		goto err_cleanup_data;
+	}
+
+	input_set_drvdata(data->input_dev, hdev);
+
+	data->input_dev->name = G13_NAME;
+	data->input_dev->phys = hdev->phys;
+	data->input_dev->uniq = hdev->uniq;
+	data->input_dev->id.bustype = hdev->bus;
+	data->input_dev->id.vendor = hdev->vendor;
+	data->input_dev->id.product = hdev->product;
+	data->input_dev->id.version = hdev->version;
+	data->input_dev->dev.parent = hdev->dev.parent;
+	data->input_dev->keycode = data->keycode;
+	data->input_dev->keycodemax = G13_KEYMAP_SIZE;
+	data->input_dev->keycodesize = sizeof(int);
+	data->input_dev->setkeycode = g13_input_setkeycode;
+	data->input_dev->getkeycode = g13_input_getkeycode;
+
+	input_set_capability(data->input_dev, EV_ABS, ABS_X);
+	input_set_capability(data->input_dev, EV_ABS, ABS_Y);
+	input_set_capability(data->input_dev, EV_MSC, MSC_SCAN);
+	input_set_capability(data->input_dev, EV_KEY, KEY_UNKNOWN);
+	data->input_dev->evbit[0] |= BIT_MASK(EV_REP);
+
+	/* 4 center values */
+	input_set_abs_params(data->input_dev, ABS_X, 0, 0xff, 0, 4);
+	input_set_abs_params(data->input_dev, ABS_Y, 0, 0xff, 0, 4);
+
+	g13_initialize_keymap(data);
+
+	error = input_register_device(data->input_dev);
+	if (error) {
+		dev_err(&hdev->dev, G13_NAME " error registering the input device");
+		error = -EINVAL;
+		goto err_cleanup_input_dev;
+	}
+
+	if (list_empty(feature_report_list)) {
+		dev_err(&hdev->dev, "no feature report found\n");
+		error = -ENODEV;
+		goto err_cleanup_input_dev_reg;
+	}
+	dbg_hid(G13_NAME " feature report found\n");
+
+	list_for_each_entry(report, feature_report_list, list) {
+		switch (report->id) {
+		case 0x04:
+			data->feature_report_4 = report;
+			break;
+		case 0x05:
+			data->led_report = report;
+			break;
+		case 0x06:
+			data->start_input_report = report;
+			break;
+		case 0x07:
+			data->backlight_report = report;
+			break;
+		default:
+			break;
+		}
+		dbg_hid(G13_NAME " Feature report: id=%u type=%u size=%u maxfield=%u report_count=%u\n",
+			report->id, report->type, report->size,
+			report->maxfield, report->field[0]->report_count);
+	}
+
+	if (list_empty(output_report_list)) {
+		dev_err(&hdev->dev, "no output report found\n");
+		error = -ENODEV;
+		goto err_cleanup_input_dev_reg;
+	}
+	dbg_hid(G13_NAME " output report found\n");
+
+	list_for_each_entry(report, output_report_list, list) {
+		dbg_hid(G13_NAME " output report %d found size=%u maxfield=%u\n", report->id, report->size, report->maxfield);
+		if (report->maxfield > 0) {
+			dbg_hid(G13_NAME " offset=%u size=%u count=%u type=%u\n",
+			       report->field[0]->report_offset,
+			       report->field[0]->report_size,
+			       report->field[0]->report_count,
+			       report->field[0]->report_type);
+		}
+		switch (report->id) {
+		case 0x03:
+			data->output_report_3 = report;
+			break;
+		}
+	}
+
+	dbg_hid("Found all reports\n");
+
+	/* Create the LED structures */
+	for (i = 0; i < 4; i++) {
+		data->led_cdev[i] = kzalloc(sizeof(struct led_classdev), GFP_KERNEL);
+		if (data->led_cdev[i] == NULL) {
+			dev_err(&hdev->dev, G13_NAME " error allocating memory for led %d", i);
+			error = -ENOMEM;
+			goto err_cleanup_led_structs;
+		}
+		/* Set the accessor functions by copying from template*/
+		*(data->led_cdev[i]) = g13_led_cdevs[i];
+
+		/*
+		 * Allocate memory for the LED name
+		 *
+		 * Since led_classdev->name is a const char* we'll use an
+		 * intermediate until the name is formatted with sprintf().
+		 */
+		led_name = kzalloc(sizeof(char)*15, GFP_KERNEL);
+		if (led_name == NULL) {
+			dev_err(&hdev->dev, G13_NAME " error allocating memory for led %d name", i);
+			error = -ENOMEM;
+			goto err_cleanup_led_structs;
+		}
+		switch (i) {
+		case 0:
+		case 1:
+		case 2:
+			sprintf(led_name, "g13_%d:red:m%d", hdev->minor, i+1);
+			break;
+		case 3:
+			sprintf(led_name, "g13_%d:red:mr", hdev->minor);
+			break;
+		}
+		data->led_cdev[i]->name = led_name;
+	}
+
+	for (i = 0; i < 4; i++) {
+		led_num = i;
+		error = led_classdev_register(&hdev->dev, data->led_cdev[i]);
+		if (error < 0) {
+			dev_err(&hdev->dev, G13_NAME " error registering led %d", i);
+			error = -EINVAL;
+			goto err_cleanup_registered_leds;
+		}
+	}
+
+	data->gfb_data = gfb_probe(hdev, GFB_PANEL_TYPE_160_43_1);
+	if (data->gfb_data == NULL) {
+		dev_err(&hdev->dev, G13_NAME " error registering framebuffer\n", i);
+		goto err_cleanup_registered_leds;
+	}
+
+	dbg_hid("Waiting for G13 to activate\n");
+
+	/* Add the sysfs attributes */
+	error = sysfs_create_group(&(hdev->dev.kobj), &g13_attr_group);
+	if (error) {
+		dev_err(&hdev->dev, G13_NAME " failed to create sysfs group attributes\n");
+		goto err_cleanup_registered_leds;
+	}
+
+	/*
+	 * Wait here for stage 1 (substages 1-3) to complete
+	 */
+	wait_for_completion_timeout(&data->ready, HZ);
+
+	/* Protect data->ready_stages before checking whether we're ready to proceed */
+	spin_lock(&data->lock);
+	if (data->ready_stages != G13_READY_STAGE_1) {
+		dev_warn(&hdev->dev, G13_NAME " hasn't completed stage 1 yet, forging ahead with initialization\n");
+		/* Force the stage */
+		data->ready_stages = G13_READY_STAGE_1;
+	}
+	init_completion(&data->ready);
+	data->ready_stages |= G13_READY_SUBSTAGE_4;
+	spin_unlock(&data->lock);
+
+	/*
+	 * Send the init report, then follow with the input report to trigger
+	 * report 6 and wait for us to get a response.
+	 */
+	g13_feature_report_4_send(hdev, G13_REPORT_4_INIT);
+	usbhid_submit_report(hdev, data->start_input_report, USB_DIR_IN);
+	wait_for_completion_timeout(&data->ready, HZ);
+
+	/* Protect data->ready_stages before checking whether we're ready to proceed */
+	spin_lock(&data->lock);
+	if (data->ready_stages != G13_READY_STAGE_2) {
+		dev_warn(&hdev->dev, G13_NAME " hasn't completed stage 2 yet, forging ahead with initialization\n");
+		/* Force the stage */
+		data->ready_stages = G13_READY_STAGE_2;
+	}
+	init_completion(&data->ready);
+	data->ready_stages |= G13_READY_SUBSTAGE_6;
+	spin_unlock(&data->lock);
+
+	/*
+	 * Clear the LEDs
+	 */
+	g13_led_send(hdev);
+
+	g13_rgb_set(hdev, G13_DEFAULT_RED, G13_DEFAULT_GREEN, G13_DEFAULT_BLUE);
+
+	/*
+	 * Send the finalize report, then follow with the input report to trigger
+	 * report 6 and wait for us to get a response.
+	 */
+	g13_feature_report_4_send(hdev, G13_REPORT_4_FINALIZE);
+	usbhid_submit_report(hdev, data->start_input_report, USB_DIR_IN);
+	usbhid_submit_report(hdev, data->start_input_report, USB_DIR_IN);
+	wait_for_completion_timeout(&data->ready, HZ);
+
+	/* Protect data->ready_stages before checking whether we're ready to proceed */
+	spin_lock(&data->lock);
+
+	if (data->ready_stages != G13_READY_STAGE_3) {
+		dev_warn(&hdev->dev, G13_NAME " hasn't completed stage 3 yet, forging ahead with initialization\n");
+		/* Force the stage */
+		data->ready_stages = G13_READY_STAGE_3;
+	} else {
+		dbg_hid(G13_NAME " stage 3 complete\n");
+	}
+
+	spin_unlock(&data->lock);
+
+	g13_set_keymap_switching(hdev, 1);
+
+	dbg_hid("G13 activated and initialized\n");
+
+	/* Everything went well */
+	return 0;
+
+err_cleanup_registered_leds:
+	for (i = 0; i < led_num; i++)
+		led_classdev_unregister(data->led_cdev[i]);
+
+err_cleanup_led_structs:
+	for (i = 0; i < 7; i++) {
+		if (data->led_cdev[i] != NULL) {
+			if (data->led_cdev[i]->name != NULL)
+				kfree(data->led_cdev[i]->name);
+			kfree(data->led_cdev[i]);
+		}
+	}
+
+err_cleanup_input_dev_reg:
+	input_unregister_device(data->input_dev);
+
+err_cleanup_input_dev:
+	input_free_device(data->input_dev);
+
+err_cleanup_data:
+	/* Make sure we clean up the allocated data structure */
+	kfree(data);
+
+err_no_cleanup:
+
+	hid_set_drvdata(hdev, NULL);
+
+	return error;
+}
+
+static void g13_remove(struct hid_device *hdev)
+{
+	struct g13_data *data;
+	int i;
+
+	hdev->ll_driver->close(hdev);
+
+	hid_hw_stop(hdev);
+
+	sysfs_remove_group(&(hdev->dev.kobj), &g13_attr_group);
+
+	/* Get the internal g13 data buffer */
+	data = hid_get_drvdata(hdev);
+
+	input_unregister_device(data->input_dev);
+
+	kfree(data->name);
+
+	/* Clean up the leds */
+	for (i = 0; i < 4; i++) {
+		led_classdev_unregister(data->led_cdev[i]);
+		kfree(data->led_cdev[i]->name);
+		kfree(data->led_cdev[i]);
+	}
+
+	gfb_remove(data->gfb_data);
+
+	/* Finally, clean up the g13 data itself */
+	kfree(data);
+}
+
+static void g13_post_reset_start(struct hid_device *hdev)
+{
+	struct g13_data *data = hid_get_g13data(hdev);
+
+	spin_lock(&data->lock);
+	data->need_reset = 1;
+	spin_unlock(&data->lock);
+}
+
+static const struct hid_device_id g13_devices[] = {
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G13)
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(hid, g13_devices);
+
+static struct hid_driver g13_driver = {
+	.name			= "hid-g13",
+	.id_table		= g13_devices,
+	.probe			= g13_probe,
+	.remove			= g13_remove,
+	.raw_event		= g13_raw_event,
+};
+
+static int __init g13_init(void)
+{
+	return hid_register_driver(&g13_driver);
+}
+
+static void __exit g13_exit(void)
+{
+	hid_unregister_driver(&g13_driver);
+}
+
+module_init(g13_init);
+module_exit(g13_exit);
+MODULE_DESCRIPTION("Logitech G13 HID Driver");
+MODULE_AUTHOR("Rick L Vinyard Jr (rvinyard@cs.nmsu.edu)");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hid/hid-g15.c b/drivers/hid/hid-g15.c
new file mode 100644
index 0000000..535ced0
--- /dev/null
+++ b/drivers/hid/hid-g15.c
@@ -0,0 +1,1405 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Alistair Buxton                                 *
+ *   a.j.buxton@gmail.com                                                  *
+ *   based on hid-g13.c                                                    *
+ *                                                                         *
+ *   This program is free software: you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation, either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This driver is distributed in the hope that it will be useful, but    *
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU      *
+ *   General Public License for more details.                              *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this software. If not see <http://www.gnu.org/licenses/>.  *
+ ***************************************************************************/
+#include <linux/fb.h>
+#include <linux/hid.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/mm.h>
+#include <linux/sysfs.h>
+#include <linux/uaccess.h>
+#include <linux/usb.h>
+#include <linux/vmalloc.h>
+#include <linux/leds.h>
+#include <linux/completion.h>
+
+#include "hid-ids.h"
+#include "usbhid/usbhid.h"
+
+#include "hid-gfb.h"
+
+#define G15_NAME "Logitech G15"
+
+/* Key defines */
+#define G15_KEYS 64
+#define G15_KEYMAP_SIZE (G15_KEYS*3)
+
+/* Backlight defaults */
+#define G15_DEFAULT_RED (0)
+#define G15_DEFAULT_GREEN (255)
+#define G15_DEFAULT_BLUE (0)
+
+/* LED array indices */
+#define G15_LED_M1 0
+#define G15_LED_M2 1
+#define G15_LED_M3 2
+#define G15_LED_MR 3
+#define G15_LED_BL_KEYS 4
+#define G15_LED_BL_SCREEN 5
+#define G15_LED_BL_CONTRAST 6 /* HACK ALERT contrast is nothing like a LED */
+
+#define G15_REPORT_4_INIT	0x00
+#define G15_REPORT_4_FINALIZE	0x01
+
+#define G15_READY_SUBSTAGE_1 0x01
+#define G15_READY_SUBSTAGE_2 0x02
+#define G15_READY_SUBSTAGE_3 0x04
+#define G15_READY_STAGE_1    0x07
+#define G15_READY_SUBSTAGE_4 0x08
+#define G15_READY_SUBSTAGE_5 0x10
+#define G15_READY_STAGE_2    0x1F
+#define G15_READY_SUBSTAGE_6 0x20
+#define G15_READY_SUBSTAGE_7 0x40
+#define G15_READY_STAGE_3    0x7F
+
+#define G15_RESET_POST 0x01
+#define G15_RESET_MESSAGE_1 0x02
+#define G15_RESET_READY 0x03
+
+/* Per device data structure */
+struct g15_data {
+	/* HID reports */
+	struct hid_device *hdev;
+	struct hid_report *backlight_report;
+	struct hid_report *start_input_report;
+	struct hid_report *feature_report_4;
+	struct hid_report *led_report;
+	struct hid_report *output_report_3;
+	struct input_dev *input_dev;
+
+	/* core state */
+	char *name;
+	int keycode[G15_KEYMAP_SIZE];
+	int scancode_state[G15_KEYS];
+	u8 keys_bl;
+	u8 screen_bl;
+	u8 screen_contrast;
+	u8 led;
+	u8 curkeymap;
+	u8 keymap_switching;
+
+	/* Framebuffer */
+	struct gfb_data *gfb_data;
+
+	/* LED stuff */
+	struct led_classdev *led_cdev[7];
+
+	/* Housekeeping stuff */
+	spinlock_t lock;
+	struct completion ready;
+	int ready_stages;
+	int need_reset;
+};
+
+/* Convenience macros */
+#define hid_get_g15data(hdev) \
+	((struct g15_data *)(hid_get_drvdata(hdev)))
+
+#define input_get_hdev(idev) \
+	((struct hid_device *)(input_get_drvdata(idev)))
+
+#define input_get_g15data(idev) (hid_get_g15data(input_get_hdev(idev)))
+
+/*
+ * Keymap array indices
+ *
+ * Key    Byte  Mask Index
+ * -----  ----  ---- -----
+ * G1     0     0x01  0
+ * G13    0     0x04  2
+ * LIT    0     0x80  7
+ * G7     1     0x01  8
+ * G2     1     0x02  9
+ * G14    1     0x08 11
+ * S2     1     0x80 15
+ * G8     2     0x02 17
+ * G3     2     0x04 18
+ * G15    2     0x10 20
+ * S3     2     0x80 23
+ * G9     3     0x04 26
+ * G4     3     0x08 27
+ * G16    3     0x20 29
+ * S4     3     0x80 31
+ * G10    4     0x08 35
+ * G5     4     0x10 36
+ * G17    4     0x40 38
+ * S5     4     0x80 39
+ * M1     5     0x01 40
+ * G11    5     0x10 44
+ * G6     5     0x20 45
+ * M2     6     0x02 49
+ * G12    6     0x20 53
+ * MR     6     0x40 54
+ * M3     7     0x04 58
+ * G18    7     0x40 62
+ * S1     7     0x80 63
+ */
+static const unsigned int g15_default_key_map[G15_KEYS] = {
+KEY_RESERVED,
+KEY_UNKNOWN,
+KEY_RESERVED,
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_F, /* LIGHT */
+KEY_RESERVED,
+KEY_RESERVED,
+KEY_UNKNOWN,
+KEY_RESERVED,
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_B, /* S2 */
+KEY_UNKNOWN,
+KEY_RESERVED,
+KEY_RESERVED,
+KEY_UNKNOWN,
+KEY_RESERVED,
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_C, /* S3 */
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_RESERVED,
+KEY_RESERVED,
+KEY_UNKNOWN,
+KEY_RESERVED,
+KEY_UNKNOWN,
+KEY_D, /* S4 */
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_RESERVED,
+KEY_RESERVED,
+KEY_UNKNOWN,
+KEY_RESERVED,
+KEY_E, /* S5 */
+KEY_F21, /* M1 */
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_RESERVED,
+KEY_RESERVED,
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_F22, /* M2 */
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_RESERVED,
+KEY_F24, /* MR */
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_F23, /* M3 */
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_UNKNOWN,
+KEY_RESERVED,
+KEY_A, /* S1 */
+};
+
+static DEVICE_ATTR(fb_node, 0444, gfb_fb_node_show, NULL);
+
+static DEVICE_ATTR(fb_update_rate, 0666,
+		   gfb_fb_update_rate_show,
+		   gfb_fb_update_rate_store);
+
+static void g15_msg_send(struct hid_device *hdev, u8 msg, u8 value1, u8 value2)
+{
+	struct g15_data *data = hid_get_g15data(hdev);
+
+	data->led_report->field[0]->value[0] = msg;
+	data->led_report->field[0]->value[1] = value1;
+	data->led_report->field[0]->value[2] = value2;
+
+	usbhid_submit_report(hdev, data->led_report, USB_DIR_OUT);
+}
+
+static void g15_led_set(struct led_classdev *led_cdev,
+			 enum led_brightness value,
+			 int led_num)
+{
+	struct device *dev;
+	struct hid_device *hdev;
+	struct g15_data *data;
+	u8 mask;
+
+	/* Get the device associated with the led */
+	dev = led_cdev->dev->parent;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* Get the underlying data value */
+	data = hid_get_g15data(hdev);
+
+	mask = 0x01<<led_num;
+	if (value)
+		data->led |= mask;
+	else
+		data->led &= ~mask;
+
+	g15_msg_send(hdev, 0x04, ~(data->led), 0);
+}
+
+static void g15_led_m1_brightness_set(struct led_classdev *led_cdev,
+				      enum led_brightness value)
+{
+	g15_led_set(led_cdev, value, G15_LED_M1);
+}
+
+static void g15_led_m2_brightness_set(struct led_classdev *led_cdev,
+				      enum led_brightness value)
+{
+	g15_led_set(led_cdev, value, G15_LED_M2);
+}
+
+static void g15_led_m3_brightness_set(struct led_classdev *led_cdev,
+				      enum led_brightness value)
+{
+	g15_led_set(led_cdev, value, G15_LED_M3);
+}
+
+static void g15_led_mr_brightness_set(struct led_classdev *led_cdev,
+				      enum led_brightness value)
+{
+	g15_led_set(led_cdev, value, G15_LED_MR);
+}
+
+static enum led_brightness g15_led_brightness_get(struct led_classdev *led_cdev)
+{
+	struct device *dev;
+	struct hid_device *hdev;
+	struct g15_data *data;
+	int value = 0;
+
+	/* Get the device associated with the led */
+	dev = led_cdev->dev->parent;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* Get the underlying data value */
+	data = hid_get_g15data(hdev);
+
+	if (led_cdev == data->led_cdev[G15_LED_M1])
+		value = data->led & 0x01;
+	else if (led_cdev == data->led_cdev[G15_LED_M2])
+		value = data->led & 0x02;
+	else if (led_cdev == data->led_cdev[G15_LED_M3])
+		value = data->led & 0x04;
+	else if (led_cdev == data->led_cdev[G15_LED_MR])
+		value = data->led & 0x08;
+	else
+		dev_info(dev, G15_NAME " error retrieving LED brightness\n");
+
+	if (value)
+		return LED_FULL;
+	return LED_OFF;
+}
+
+static void g15_led_bl_set(struct led_classdev *led_cdev,
+				      enum led_brightness value)
+{
+	struct device *dev;
+	struct hid_device *hdev;
+	struct g15_data *data;
+
+	/* Get the device associated with the led */
+	dev = led_cdev->dev->parent;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* Get the underlying data value */
+	data = hid_get_g15data(hdev);
+
+	if (led_cdev == data->led_cdev[G15_LED_BL_KEYS]) {
+		if (value > 2)
+			value = 2;
+		data->keys_bl = value;
+		g15_msg_send(hdev, 0x01, data->keys_bl, 0);
+	} else if (led_cdev == data->led_cdev[G15_LED_BL_SCREEN]) {
+		if (value > 2)
+			value = 2;
+		data->screen_bl = value<<4;
+		g15_msg_send(hdev, 0x02, data->screen_bl, 0);
+	} else if (led_cdev == data->led_cdev[G15_LED_BL_CONTRAST]) {
+		if (value > 63)
+			value = 63;
+		data->screen_contrast = value;
+		g15_msg_send(hdev, 32, 129, data->screen_contrast);
+	} else
+		dev_info(dev, G15_NAME " error retrieving LED brightness\n");
+
+}
+
+static int g15_led_bl_get(struct led_classdev *led_cdev)
+{
+	struct device *dev;
+	struct hid_device *hdev;
+	struct g15_data *data;
+
+	/* Get the device associated with the led */
+	dev = led_cdev->dev->parent;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* Get the underlying data value */
+	data = hid_get_g15data(hdev);
+
+	if (led_cdev == data->led_cdev[G15_LED_BL_KEYS])
+		return data->keys_bl;
+	else if (led_cdev == data->led_cdev[G15_LED_BL_SCREEN])
+		return data->screen_bl;
+	else if (led_cdev == data->led_cdev[G15_LED_BL_CONTRAST])
+		return data->screen_contrast;
+	else
+		dev_info(dev, G15_NAME " error retrieving LED brightness\n");
+
+	return 0;
+}
+
+static const struct led_classdev g15_led_cdevs[7] = {
+	{
+		.brightness_set		= g15_led_m1_brightness_set,
+		.brightness_get		= g15_led_brightness_get,
+	},
+	{
+		.brightness_set		= g15_led_m2_brightness_set,
+		.brightness_get		= g15_led_brightness_get,
+	},
+	{
+		.brightness_set		= g15_led_m3_brightness_set,
+		.brightness_get		= g15_led_brightness_get,
+	},
+	{
+		.brightness_set		= g15_led_mr_brightness_set,
+		.brightness_get		= g15_led_brightness_get,
+	},
+	{
+		.brightness_set		= g15_led_bl_set,
+		.brightness_get		= g15_led_bl_get,
+	},
+	{
+		.brightness_set		= g15_led_bl_set,
+		.brightness_get		= g15_led_bl_get,
+	},
+	{
+		.brightness_set		= g15_led_bl_set,
+		.brightness_get		= g15_led_bl_get,
+	},
+};
+
+static int g15_input_setkeycode(struct input_dev *dev,
+				int scancode,
+				int keycode)
+{
+	int old_keycode;
+	int i;
+	struct g15_data *data = input_get_g15data(dev);
+
+	if (scancode >= dev->keycodemax)
+		return -EINVAL;
+
+	spin_lock(&data->lock);
+
+	old_keycode = data->keycode[scancode];
+	data->keycode[scancode] = keycode;
+
+	__clear_bit(old_keycode, dev->keybit);
+	__set_bit(keycode, dev->keybit);
+
+	for (i = 0; i < dev->keycodemax; i++) {
+		if (data->keycode[i] == old_keycode) {
+			__set_bit(old_keycode, dev->keybit);
+			break; /* Setting the bit twice is useless, so break*/
+		}
+	}
+
+	spin_unlock(&data->lock);
+
+	return 0;
+}
+
+static int g15_input_getkeycode(struct input_dev *dev,
+				int scancode,
+				int *keycode)
+{
+	struct g15_data *data = input_get_g15data(dev);
+
+	if (!dev->keycodesize)
+		return -EINVAL;
+
+	if (scancode >= dev->keycodemax)
+		return -EINVAL;
+
+	*keycode = data->keycode[scancode];
+
+	return 0;
+}
+
+
+/*
+ * The "keymap" attribute
+ */
+static ssize_t g15_keymap_index_show(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct g15_data *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", data->curkeymap);
+}
+
+static ssize_t g15_set_keymap_index(struct hid_device *hdev, unsigned k)
+{
+	int scancode;
+	int offset_old;
+	int offset_new;
+	int keycode_old;
+	int keycode_new;
+	struct g15_data *data = hid_get_g15data(hdev);
+	struct input_dev *idev = data->input_dev;
+
+	if (k > 2)
+		return -EINVAL;
+
+	/*
+	 * Release all the pressed keys unless the new keymap has the same key
+	 * in the same scancode position.
+	 *
+	 * Also, clear the scancode state unless the new keymap has the same
+	 * key in the same scancode position.
+	 *
+	 * This allows a keycode mapped to the same scancode in two different
+	 * keymaps to remain pressed without a key up code when the keymap is
+	 * switched.
+	 */
+	offset_old = G15_KEYS * data->curkeymap;
+	offset_new = G15_KEYS * k;
+	for (scancode = 0; scancode < G15_KEYS; scancode++) {
+		keycode_old = data->keycode[offset_old+scancode];
+		keycode_new = data->keycode[offset_new+scancode];
+		if (keycode_old != keycode_new) {
+			if (keycode_old != KEY_RESERVED)
+				input_report_key(idev, keycode_old, 0);
+			data->scancode_state[scancode] = 0;
+		}
+	}
+
+	data->curkeymap = k;
+
+	if (data->keymap_switching) {
+		data->led = 1 << k;
+		g15_msg_send(hdev, 4, ~data->led, 0);
+	}
+
+	return 0;
+}
+
+static ssize_t g15_keymap_index_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct hid_device *hdev;
+	int i;
+	unsigned k;
+	ssize_t set_result;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* If we have an invalid pointer we'll return ENODATA */
+	if (hdev == NULL || &(hdev->dev) != dev)
+		return -ENODATA;
+
+	i = sscanf(buf, "%u", &k);
+	if (i != 1) {
+		dev_warn(dev, G15_NAME " unrecognized input: %s", buf);
+		return -1;
+	}
+
+	set_result = g15_set_keymap_index(hdev, k);
+
+	if (set_result < 0)
+		return set_result;
+
+	return count;
+}
+
+static DEVICE_ATTR(keymap_index, 0666,
+		   g15_keymap_index_show,
+		   g15_keymap_index_store);
+
+/*
+ * The "keycode" attribute
+ */
+static ssize_t g15_keymap_show(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	int offset = 0;
+	int result;
+	int scancode;
+	int keycode;
+	int error;
+
+	struct g15_data *data = dev_get_drvdata(dev);
+
+	for (scancode = 0; scancode < G15_KEYMAP_SIZE; scancode++) {
+		error = input_get_keycode(data->input_dev, scancode, &keycode);
+		if (error) {
+			dev_warn(dev, G15_NAME " error accessing scancode %d\n",
+				 scancode);
+			continue;
+		}
+
+		result = sprintf(buf+offset, "0x%03x 0x%04x\n",
+				 scancode, keycode);
+		if (result < 0)
+			return -EINVAL;
+		offset += result;
+	}
+
+	return offset+1;
+}
+
+static ssize_t g15_keymap_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct hid_device *hdev;
+	int scanned;
+	int consumed;
+	int scancd;
+	int keycd;
+	int error;
+	int set = 0;
+	int gkey;
+	int index;
+	int good;
+	struct g15_data *data;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* If we have an invalid pointer we'll return ENODATA */
+	if (hdev == NULL || &(hdev->dev) != dev)
+		return -ENODATA;
+
+	/* Now, let's get the data structure */
+	data = hid_get_g15data(hdev);
+
+	do {
+		good = 0;
+
+		/* Look for scancode keycode pair in hex */
+		scanned = sscanf(buf, "%x %x%n", &scancd, &keycd, &consumed);
+		if (scanned == 2) {
+			buf += consumed;
+			error = g15_input_setkeycode(data->input_dev, scancd, keycd);
+			if (error)
+				goto err_input_setkeycode;
+			set++;
+			good = 1;
+		} else {
+			/*
+			 * Look for Gkey keycode pair and assign to current
+			 * keymap
+			 */
+			scanned = sscanf(buf, "G%d %x%n", &gkey, &keycd, &consumed);
+			if (scanned == 2 && gkey > 0 && gkey <= G15_KEYS) {
+				buf += consumed;
+				scancd = data->curkeymap * G15_KEYS + gkey - 1;
+				error = g15_input_setkeycode(data->input_dev, scancd, keycd);
+				if (error)
+					goto err_input_setkeycode;
+				set++;
+				good = 1;
+			} else {
+				/*
+				 * Look for Gkey-index keycode pair and assign
+				 * to indexed keymap
+				 */
+				scanned = sscanf(buf, "G%d-%d %x%n", &gkey, &index, &keycd, &consumed);
+				if (scanned == 3 &&
+				    gkey > 0 && gkey <= G15_KEYS &&
+				    index >= 0 && index <= 2) {
+					buf += consumed;
+					scancd = index * G15_KEYS + gkey - 1;
+					error = g15_input_setkeycode(data->input_dev, scancd, keycd);
+					if (error)
+						goto err_input_setkeycode;
+					set++;
+					good = 1;
+				}
+			}
+		}
+
+	} while (good);
+
+	if (set == 0) {
+		dev_warn(dev, G15_NAME " unrecognized keycode input: %s", buf);
+		return -1;
+	}
+
+	return count;
+
+err_input_setkeycode:
+	dev_warn(dev, G15_NAME " error setting scancode %d to keycode %d\n",
+		 scancd, keycd);
+	return error;
+}
+
+static DEVICE_ATTR(keymap, 0666, g15_keymap_show, g15_keymap_store);
+
+/*
+ * The "keymap_switching" attribute
+ */
+static ssize_t g15_keymap_switching_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct g15_data *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", data->keymap_switching);
+}
+
+static ssize_t g15_set_keymap_switching(struct hid_device *hdev, unsigned k)
+{
+	struct g15_data *data = hid_get_g15data(hdev);
+
+	data->keymap_switching = k;
+
+	if (data->keymap_switching) {
+		data->led = 1 << data->curkeymap;
+		g15_msg_send(hdev, 4, ~data->led, 0);
+	}
+
+	return 0;
+}
+
+static ssize_t g15_keymap_switching_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct hid_device *hdev;
+	int i;
+	unsigned k;
+	ssize_t set_result;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* If we have an invalid pointer we'll return ENODATA */
+	if (hdev == NULL || &(hdev->dev) != dev)
+		return -ENODATA;
+
+	i = sscanf(buf, "%u", &k);
+	if (i != 1) {
+		dev_warn(dev, G15_NAME "unrecognized input: %s", buf);
+		return -1;
+	}
+
+	set_result = g15_set_keymap_switching(hdev, k);
+
+	if (set_result < 0)
+		return set_result;
+
+	return count;
+}
+
+static DEVICE_ATTR(keymap_switching, 0644,
+		   g15_keymap_switching_show,
+		   g15_keymap_switching_store);
+
+
+static ssize_t g15_name_show(struct device *dev,
+			     struct device_attribute *attr,
+			     char *buf)
+{
+	struct g15_data *data = dev_get_drvdata(dev);
+	int result;
+
+	if (data->name == NULL) {
+		buf[0] = 0x00;
+		return 1;
+	}
+
+	spin_lock(&data->lock);
+	result = sprintf(buf, "%s", data->name);
+	spin_unlock(&data->lock);
+
+	return result;
+}
+
+static ssize_t g15_name_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct g15_data *data = dev_get_drvdata(dev);
+	size_t limit = count;
+	char *end;
+
+	spin_lock(&data->lock);
+
+	if (data->name != NULL) {
+		kfree(data->name);
+		data->name = NULL;
+	}
+
+	end = strpbrk(buf, "\n\r");
+	if (end != NULL)
+		limit = end - buf;
+
+	if (end != buf) {
+
+		if (limit > 100)
+			limit = 100;
+
+		data->name = kzalloc(limit+1, GFP_ATOMIC);
+
+		strncpy(data->name, buf, limit);
+	}
+
+	spin_unlock(&data->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(name, 0666, g15_name_show, g15_name_store);
+
+static void g15_feature_report_4_send(struct hid_device *hdev, int which)
+{
+	struct g15_data *data = hid_get_g15data(hdev);
+
+	if (which == G15_REPORT_4_INIT) {
+		data->feature_report_4->field[0]->value[0] = 0x02;
+		data->feature_report_4->field[0]->value[1] = 0x00;
+		data->feature_report_4->field[0]->value[2] = 0x00;
+		data->feature_report_4->field[0]->value[3] = 0x00;
+	} else if (which == G15_REPORT_4_FINALIZE) {
+		data->feature_report_4->field[0]->value[0] = 0x02;
+		data->feature_report_4->field[0]->value[1] = 0x80;
+		data->feature_report_4->field[0]->value[2] = 0x00;
+		data->feature_report_4->field[0]->value[3] = 0xFF;
+	} else {
+		return;
+	}
+
+	usbhid_submit_report(hdev, data->feature_report_4, USB_DIR_OUT);
+}
+
+/*
+ * The "minor" attribute
+ */
+static ssize_t g15_minor_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	struct g15_data *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", data->hdev->minor);
+}
+
+static DEVICE_ATTR(minor, 0444, g15_minor_show, NULL);
+
+/*
+ * Create a group of attributes so that we can create and destroy them all
+ * at once.
+ */
+static struct attribute *g15_attrs[] = {
+	&dev_attr_name.attr,
+	&dev_attr_keymap_index.attr,
+	&dev_attr_keymap_switching.attr,
+	&dev_attr_keymap.attr,
+	&dev_attr_minor.attr,
+	&dev_attr_fb_update_rate.attr,
+	&dev_attr_fb_node.attr,
+	NULL,	/* need to NULL terminate the list of attributes */
+};
+
+/*
+ * An unnamed attribute group will put all of the attributes directly in
+ * the kobject directory.  If we specify a name, a subdirectory will be
+ * created for the attributes with the directory being the name of the
+ * attribute group.
+ */
+static struct attribute_group g15_attr_group = {
+	.attrs = g15_attrs,
+};
+
+static void g15_handle_key_event(struct g15_data *data,
+				 struct input_dev *idev,
+				 int scancode,
+				 int value)
+{
+	int error;
+	int keycode;
+	int offset;
+
+	offset = G15_KEYS * data->curkeymap;
+
+	error = input_get_keycode(idev, scancode+offset, &keycode);
+
+	if (unlikely(error)) {
+		dev_warn(&idev->dev, G15_NAME " error in input_get_keycode(): scancode=%d\n", scancode);
+		return;
+	}
+
+	/* Only report mapped keys */
+	if (keycode != KEY_RESERVED)
+		input_report_key(idev, keycode, value);
+	/* Or report MSC_SCAN on keypress of an unmapped key */
+/*	else if (data->scancode_state[scancode] == 0 && value)
+		input_event(idev, EV_MSC, MSC_SCAN, scancode);
+*/
+	data->scancode_state[scancode] = value;
+}
+
+static void g15_raw_event_process_input(struct hid_device *hdev,
+					struct g15_data *data,
+					u8 *raw_data)
+{
+	struct input_dev *idev = data->input_dev;
+	int scancode;
+	int value;
+	int i;
+	int mask;
+
+	/*
+	 * We'll check for the M* keys being pressed before processing
+	 * the remainder of the key data. That way the new keymap will
+	 * be loaded if there is a keymap switch.
+	 */
+/*	if (unlikely(data->keymap_switching)) {
+		if (data->curkeymap != 0 && raw_data[5] & 0x01)
+			g15_set_keymap_index(hdev, 0);
+		else if (data->curkeymap != 1 && raw_data[6] & 0x02)
+			g15_set_keymap_index(hdev, 1);
+		else if (data->curkeymap != 2 && raw_data[7] & 0x04)
+			g15_set_keymap_index(hdev, 2);
+	}
+*/
+	raw_data[4] &= 0xFE; /* This bit turns on and off at random */
+
+	for (i = 0, mask = 0x01; i < 8; i++, mask <<= 1) {
+		scancode = i;
+		value = raw_data[1] & mask;
+		g15_handle_key_event(data, idev, scancode, value);
+
+		scancode = i + 8;
+		value = raw_data[2] & mask;
+		g15_handle_key_event(data, idev, scancode, value);
+
+		scancode = i + 16;
+		value = raw_data[3] & mask;
+		g15_handle_key_event(data, idev, scancode, value);
+
+		scancode = i + 24;
+		value = raw_data[4] & mask;
+		g15_handle_key_event(data, idev, scancode, value);
+
+		scancode = i + 32;
+		value = raw_data[5] & mask;
+		g15_handle_key_event(data, idev, scancode, value);
+
+		scancode = i + 40;
+		value = raw_data[6] & mask;
+		g15_handle_key_event(data, idev, scancode, value);
+
+		scancode = i + 48;
+		value = raw_data[7] & mask;
+		g15_handle_key_event(data, idev, scancode, value);
+
+		scancode = i + 56;
+		value = raw_data[8] & mask;
+		g15_handle_key_event(data, idev, scancode, value);
+	}
+
+	input_sync(idev);
+}
+
+static int g15_raw_event(struct hid_device *hdev,
+			 struct hid_report *report,
+			 u8 *raw_data, int size)
+{
+	/*
+	* On initialization receive a 258 byte message with
+	* data = 6 0 255 255 255 255 255 255 255 255 ...
+	*/
+	struct g15_data *data;
+	data = dev_get_drvdata(&hdev->dev);
+
+	spin_lock(&data->lock);
+
+	if (unlikely(data->need_reset)) {
+		g15_msg_send(hdev, 4, ~data->led, 0);
+		data->need_reset = 0;
+		spin_unlock(&data->lock);
+		return 1;
+	}
+
+	if (unlikely(data->ready_stages != G15_READY_STAGE_3)) {
+		switch (report->id) {
+		case 6:
+			if (!(data->ready_stages & G15_READY_SUBSTAGE_1))
+				data->ready_stages |= G15_READY_SUBSTAGE_1;
+			else if (data->ready_stages & G15_READY_SUBSTAGE_4 &&
+				 !(data->ready_stages & G15_READY_SUBSTAGE_5)
+				)
+				data->ready_stages |= G15_READY_SUBSTAGE_5;
+			else if (data->ready_stages & G15_READY_SUBSTAGE_6 &&
+				 raw_data[1] >= 0x80)
+				data->ready_stages |= G15_READY_SUBSTAGE_7;
+			break;
+		case 1:
+			if (!(data->ready_stages & G15_READY_SUBSTAGE_2))
+				data->ready_stages |= G15_READY_SUBSTAGE_2;
+			else
+				data->ready_stages |= G15_READY_SUBSTAGE_3;
+			break;
+		}
+
+		if (data->ready_stages == G15_READY_STAGE_1 ||
+		    data->ready_stages == G15_READY_STAGE_2 ||
+		    data->ready_stages == G15_READY_STAGE_3)
+			complete_all(&data->ready);
+
+		spin_unlock(&data->lock);
+		return 1;
+	}
+
+	spin_unlock(&data->lock);
+
+	if (likely(report->id == 2)) {
+		g15_raw_event_process_input(hdev, data, raw_data);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void g15_initialize_keymap(struct g15_data *data)
+{
+	int i;
+
+	for (i = 0; i < G15_KEYS; i++) {
+		data->keycode[i] = g15_default_key_map[i];
+		__set_bit(data->keycode[i], data->input_dev->keybit);
+	}
+
+	__clear_bit(KEY_RESERVED, data->input_dev->keybit);
+}
+
+static int g15_probe(struct hid_device *hdev,
+		     const struct hid_device_id *id)
+{
+	int error;
+	struct g15_data *data;
+	int i;
+	int led_num;
+	struct usb_interface *intf;
+	struct usb_device *usbdev;
+	struct list_head *feature_report_list =
+		&hdev->report_enum[HID_FEATURE_REPORT].report_list;
+	struct list_head *output_report_list =
+			&hdev->report_enum[HID_OUTPUT_REPORT].report_list;
+	struct hid_report *report;
+	char *led_name;
+
+	dev_dbg(&hdev->dev, "Logitech G15 HID hardware probe...");
+
+	/* Get the usb device to send the start report on */
+	intf = to_usb_interface(hdev->dev.parent);
+	usbdev = interface_to_usbdev(intf);
+
+	/*
+	 * Let's allocate the g15 data structure, set some reasonable
+	 * defaults, and associate it with the device
+	 */
+	data = kzalloc(sizeof(struct g15_data), GFP_KERNEL);
+	if (data == NULL) {
+		dev_err(&hdev->dev, "can't allocate space for Logitech G15 device attributes\n");
+		error = -ENOMEM;
+		goto err_no_cleanup;
+	}
+
+	spin_lock_init(&data->lock);
+
+	init_completion(&data->ready);
+
+	data->hdev = hdev;
+
+	hid_set_drvdata(hdev, data);
+
+	dbg_hid("Preparing to parse " G15_NAME " hid reports\n");
+
+	/* Parse the device reports and start it up */
+	error = hid_parse(hdev);
+	if (error) {
+		dev_err(&hdev->dev, G15_NAME " device report parse failed\n");
+		error = -EINVAL;
+		goto err_cleanup_data;
+	}
+
+	error = hid_hw_start(hdev, HID_CONNECT_DEFAULT | HID_CONNECT_HIDINPUT_FORCE);
+	if (error) {
+		dev_err(&hdev->dev, G15_NAME " hardware start failed\n");
+		error = -EINVAL;
+		goto err_cleanup_data;
+	}
+
+	dbg_hid(G15_NAME " claimed: %d\n", hdev->claimed);
+
+	error = hdev->ll_driver->open(hdev);
+	if (error) {
+		dev_err(&hdev->dev, G15_NAME " failed to open input interrupt pipe for key and joystick events\n");
+		error = -EINVAL;
+		goto err_cleanup_data;
+	}
+
+	/* Set up the input device for the key I/O */
+	data->input_dev = input_allocate_device();
+	if (data->input_dev == NULL) {
+		dev_err(&hdev->dev, G15_NAME " error initializing the input device");
+		error = -ENOMEM;
+		goto err_cleanup_data;
+	}
+
+	input_set_drvdata(data->input_dev, hdev);
+
+	data->input_dev->name = G15_NAME;
+	data->input_dev->phys = hdev->phys;
+	data->input_dev->uniq = hdev->uniq;
+	data->input_dev->id.bustype = hdev->bus;
+	data->input_dev->id.vendor = hdev->vendor;
+	data->input_dev->id.product = hdev->product;
+	data->input_dev->id.version = hdev->version;
+	data->input_dev->dev.parent = hdev->dev.parent;
+	data->input_dev->keycode = data->keycode;
+	data->input_dev->keycodemax = G15_KEYMAP_SIZE;
+	data->input_dev->keycodesize = sizeof(int);
+	data->input_dev->setkeycode = g15_input_setkeycode;
+	data->input_dev->getkeycode = g15_input_getkeycode;
+
+	input_set_capability(data->input_dev, EV_KEY, KEY_UNKNOWN);
+	data->input_dev->evbit[0] |= BIT_MASK(EV_REP);
+
+	g15_initialize_keymap(data);
+
+	error = input_register_device(data->input_dev);
+	if (error) {
+		dev_err(&hdev->dev, G15_NAME " error registering the input device");
+		error = -EINVAL;
+		goto err_cleanup_input_dev;
+	}
+
+	dbg_hid(KERN_INFO G15_NAME " allocated framebuffer\n");
+
+	dbg_hid(KERN_INFO G15_NAME " allocated deferred IO structure\n");
+
+	if (list_empty(feature_report_list)) {
+		dev_err(&hdev->dev, "no feature report found\n");
+		error = -ENODEV;
+		goto err_cleanup_input_dev_reg;
+	}
+	dbg_hid(G15_NAME " feature report found\n");
+
+	list_for_each_entry(report, feature_report_list, list) {
+		switch (report->id) {
+		case 0x02: /* G15 has only one feature report 0x02 */
+			data->feature_report_4 = data->led_report = data->start_input_report = data->backlight_report = report;
+			break;
+		default:
+			break;
+		}
+		dbg_hid(G15_NAME " Feature report: id=%u type=%u size=%u maxfield=%u report_count=%u\n",
+			report->id, report->type, report->size,
+			report->maxfield, report->field[0]->report_count);
+	}
+
+	if (list_empty(output_report_list)) {
+		dev_err(&hdev->dev, "no output report found\n");
+		error = -ENODEV;
+		goto err_cleanup_input_dev_reg;
+	}
+	dbg_hid(G15_NAME " output report found\n");
+
+	list_for_each_entry(report, output_report_list, list) {
+		dbg_hid(G15_NAME " output report %d found size=%u maxfield=%u\n", report->id, report->size, report->maxfield);
+		if (report->maxfield > 0) {
+			dbg_hid(G15_NAME " offset=%u size=%u count=%u type=%u\n",
+			       report->field[0]->report_offset,
+			       report->field[0]->report_size,
+			       report->field[0]->report_count,
+			       report->field[0]->report_type);
+		}
+		switch (report->id) {
+		case 0x03:
+			data->output_report_3 = report;
+			break;
+		}
+	}
+
+	dbg_hid("Found all reports\n");
+
+	/* Create the LED structures */
+	for (i = 0; i < 7; i++) {
+		data->led_cdev[i] = kzalloc(sizeof(struct led_classdev), GFP_KERNEL);
+		if (data->led_cdev[i] == NULL) {
+			dev_err(&hdev->dev, G15_NAME " error allocating memory for led %d", i);
+			error = -ENOMEM;
+			goto err_cleanup_led_structs;
+		}
+		/* Set the accessor functions by copying from template*/
+		*(data->led_cdev[i]) = g15_led_cdevs[i];
+
+		/*
+		 * Allocate memory for the LED name
+		 *
+		 * Since led_classdev->name is a const char* we'll use an
+		 * intermediate until the name is formatted with sprintf().
+		 */
+		led_name = kzalloc(sizeof(char)*30, GFP_KERNEL);
+		if (led_name == NULL) {
+			dev_err(&hdev->dev, G15_NAME " error allocating memory for led %d name", i);
+			error = -ENOMEM;
+			goto err_cleanup_led_structs;
+		}
+		switch (i) {
+		case 0:
+		case 1:
+		case 2:
+			sprintf(led_name, "g15_%d:orange:m%d", hdev->minor, i+1);
+			break;
+		case 3:
+			sprintf(led_name, "g15_%d:blue:mr", hdev->minor);
+			break;
+		case 4:
+			sprintf(led_name, "g15_%d:blue:keys", hdev->minor);
+			break;
+		case 5:
+			sprintf(led_name, "g15_%d:white:screen", hdev->minor);
+			break;
+		case 6:
+			sprintf(led_name, "g15_%d:contrast:screen", hdev->minor);
+			break;
+		}
+		data->led_cdev[i]->name = led_name;
+	}
+
+	for (i = 0; i < 7; i++) {
+		led_num = i;
+		error = led_classdev_register(&hdev->dev, data->led_cdev[i]);
+		if (error < 0) {
+			dev_err(&hdev->dev, G15_NAME " error registering led %d\n", i);
+			error = -EINVAL;
+			goto err_cleanup_registered_leds;
+		}
+	}
+
+	data->gfb_data = gfb_probe(hdev, GFB_PANEL_TYPE_160_43_1);
+	if (data->gfb_data == NULL) {
+		dev_err(&hdev->dev, G15_NAME " error registering framebuffer\n", i);
+		goto err_cleanup_registered_leds;
+	}
+
+	dbg_hid("Waiting for G15 to activate\n");
+
+	/* Add the sysfs attributes */
+	error = sysfs_create_group(&(hdev->dev.kobj), &g15_attr_group);
+	if (error) {
+		dev_err(&hdev->dev, G15_NAME " failed to create sysfs group attributes\n");
+		goto err_cleanup_registered_leds;
+	}
+
+	/*
+	 * Wait here for stage 1 (substages 1-3) to complete
+	 */
+	wait_for_completion_timeout(&data->ready, HZ);
+
+	/* Protect data->ready_stages before checking whether we're ready to proceed */
+	spin_lock(&data->lock);
+	if (data->ready_stages != G15_READY_STAGE_1) {
+		dev_warn(&hdev->dev, G15_NAME " hasn't completed stage 1 yet, forging ahead with initialization\n");
+		/* Force the stage */
+		data->ready_stages = G15_READY_STAGE_1;
+	}
+	init_completion(&data->ready);
+	data->ready_stages |= G15_READY_SUBSTAGE_4;
+	spin_unlock(&data->lock);
+
+	/*
+	 * Send the init report, then follow with the input report to trigger
+	 * report 6 and wait for us to get a response.
+	 */
+	g15_feature_report_4_send(hdev, G15_REPORT_4_INIT);
+	usbhid_submit_report(hdev, data->start_input_report, USB_DIR_IN);
+	wait_for_completion_timeout(&data->ready, HZ);
+
+	/* Protect data->ready_stages before checking whether we're ready to proceed */
+	spin_lock(&data->lock);
+	if (data->ready_stages != G15_READY_STAGE_2) {
+		dev_warn(&hdev->dev, G15_NAME " hasn't completed stage 2 yet, forging ahead with initialization\n");
+		/* Force the stage */
+		data->ready_stages = G15_READY_STAGE_2;
+	}
+	init_completion(&data->ready);
+	data->ready_stages |= G15_READY_SUBSTAGE_6;
+	spin_unlock(&data->lock);
+
+	/*
+	 * Clear the LEDs
+	 */
+	g15_msg_send(hdev, 4, ~data->led, 0);
+
+	/*
+	 * Send the finalize report, then follow with the input report to trigger
+	 * report 6 and wait for us to get a response.
+	 */
+	g15_feature_report_4_send(hdev, G15_REPORT_4_FINALIZE);
+	usbhid_submit_report(hdev, data->start_input_report, USB_DIR_IN);
+	usbhid_submit_report(hdev, data->start_input_report, USB_DIR_IN);
+	wait_for_completion_timeout(&data->ready, HZ);
+
+	/* Protect data->ready_stages before checking whether we're ready to proceed */
+	spin_lock(&data->lock);
+
+	if (data->ready_stages != G15_READY_STAGE_3) {
+		dev_warn(&hdev->dev, G15_NAME " hasn't completed stage 3 yet, forging ahead with initialization\n");
+		/* Force the stage */
+		data->ready_stages = G15_READY_STAGE_3;
+	} else {
+		dbg_hid(G15_NAME " stage 3 complete\n");
+	}
+
+	spin_unlock(&data->lock);
+
+	g15_set_keymap_switching(hdev, 1);
+
+	dbg_hid("G15 activated and initialized\n");
+
+	/* Everything went well */
+	return 0;
+
+err_cleanup_registered_leds:
+	for (i = 0; i < led_num; i++)
+		led_classdev_unregister(data->led_cdev[i]);
+
+err_cleanup_led_structs:
+	for (i = 0; i < 7; i++) {
+		if (data->led_cdev[i] != NULL) {
+			if (data->led_cdev[i]->name != NULL)
+				kfree(data->led_cdev[i]->name);
+			kfree(data->led_cdev[i]);
+		}
+	}
+
+err_cleanup_input_dev_reg:
+	input_unregister_device(data->input_dev);
+
+err_cleanup_input_dev:
+	input_free_device(data->input_dev);
+
+err_cleanup_data:
+	/* Make sure we clean up the allocated data structure */
+	kfree(data);
+
+err_no_cleanup:
+
+	hid_set_drvdata(hdev, NULL);
+
+	return error;
+}
+
+static void g15_remove(struct hid_device *hdev)
+{
+	struct g15_data *data;
+	int i;
+
+	hdev->ll_driver->close(hdev);
+
+	hid_hw_stop(hdev);
+
+	sysfs_remove_group(&(hdev->dev.kobj), &g15_attr_group);
+
+	/* Get the internal g15 data buffer */
+	data = hid_get_drvdata(hdev);
+
+	input_unregister_device(data->input_dev);
+
+	kfree(data->name);
+
+	/* Clean up the leds */
+	for (i = 0; i < 7; i++) {
+		led_classdev_unregister(data->led_cdev[i]);
+		kfree(data->led_cdev[i]->name);
+		kfree(data->led_cdev[i]);
+	}
+
+	gfb_remove(data->gfb_data);
+
+	/* Finally, clean up the g15 data itself */
+	kfree(data);
+}
+
+static void g15_post_reset_start(struct hid_device *hdev)
+{
+	struct g15_data *data = hid_get_g15data(hdev);
+
+	spin_lock(&data->lock);
+	data->need_reset = 1;
+	spin_unlock(&data->lock);
+}
+
+static const struct hid_device_id g15_devices[] = {
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G15_LCD)
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(hid, g15_devices);
+
+static struct hid_driver g15_driver = {
+	.name			= "hid-g15",
+	.id_table		= g15_devices,
+	.probe			= g15_probe,
+	.remove			= g15_remove,
+	.raw_event		= g15_raw_event,
+};
+
+static int __init g15_init(void)
+{
+	return hid_register_driver(&g15_driver);
+}
+
+static void __exit g15_exit(void)
+{
+	hid_unregister_driver(&g15_driver);
+}
+
+module_init(g15_init);
+module_exit(g15_exit);
+MODULE_DESCRIPTION("Logitech G15 HID Driver");
+MODULE_AUTHOR("Alistair Buxton (a.j.buxton@gmail.com)");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hid/hid-g19.c b/drivers/hid/hid-g19.c
new file mode 100644
index 0000000..60a24c5
--- /dev/null
+++ b/drivers/hid/hid-g19.c
@@ -0,0 +1,1394 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Alistair Buxton                                 *
+ *   a.j.buxton@gmail.com                                                  *
+ *   based on hid-g13.c                                                    *
+ *                                                                         *
+ *   This program is free software: you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation, either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This driver is distributed in the hope that it will be useful, but    *
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU      *
+ *   General Public License for more details.                              *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this software. If not see <http://www.gnu.org/licenses/>.  *
+ ***************************************************************************/
+#include <linux/fb.h>
+#include <linux/hid.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/mm.h>
+#include <linux/sysfs.h>
+#include <linux/uaccess.h>
+#include <linux/usb.h>
+#include <linux/vmalloc.h>
+#include <linux/leds.h>
+#include <linux/completion.h>
+
+#include "hid-ids.h"
+#include "usbhid/usbhid.h"
+
+#include "hid-gfb.h"
+
+#define G19_NAME "Logitech G19"
+
+/* Key defines */
+#define G19_KEYS 32
+#define G19_KEYMAP_SIZE (G19_KEYS*3)
+
+/* Backlight defaults */
+#define G19_DEFAULT_RED (0)
+#define G19_DEFAULT_GREEN (255)
+#define G19_DEFAULT_BLUE (0)
+
+/* LED array indices */
+#define G19_LED_M1 0
+#define G19_LED_M2 1
+#define G19_LED_M3 2
+#define G19_LED_MR 3
+#define G19_LED_BL_R 4
+#define G19_LED_BL_G 5
+#define G19_LED_BL_B 6
+
+#define G19_REPORT_4_INIT	0x00
+#define G19_REPORT_4_FINALIZE	0x01
+
+#define G19_READY_SUBSTAGE_1 0x01
+#define G19_READY_SUBSTAGE_2 0x02
+#define G19_READY_SUBSTAGE_3 0x04
+#define G19_READY_STAGE_1    0x07
+#define G19_READY_SUBSTAGE_4 0x08
+#define G19_READY_SUBSTAGE_5 0x10
+#define G19_READY_STAGE_2    0x1F
+#define G19_READY_SUBSTAGE_6 0x20
+#define G19_READY_SUBSTAGE_7 0x40
+#define G19_READY_STAGE_3    0x7F
+
+#define G19_RESET_POST 0x01
+#define G19_RESET_MESSAGE_1 0x02
+#define G19_RESET_READY 0x03
+
+/* Per device data structure */
+struct g19_data {
+	/* HID reports */
+	struct hid_device *hdev;
+	struct hid_report *backlight_report;
+	struct hid_report *start_input_report;
+	struct hid_report *feature_report_4;
+	struct hid_report *led_report;
+	struct hid_report *output_report_3;
+	struct input_dev *input_dev;
+
+	/* core state */
+	char *name;
+	int keycode[G19_KEYMAP_SIZE];
+	int scancode_state[G19_KEYS];
+	u8 rgb[3];
+	u8 led;
+	u8 curkeymap;
+	u8 keymap_switching;
+
+	/* Framebuffer */
+	struct gfb_data *gfb_data;
+
+	/* none standard buttons stuff */
+	u8 ep1keys[2];
+	struct urb *ep1_urb;
+	spinlock_t ep1_urb_lock;
+
+	/* LED stuff */
+	struct led_classdev *led_cdev[7];
+
+	/* Housekeeping stuff */
+	spinlock_t lock;
+	struct completion ready;
+	int ready_stages;
+	int need_reset;
+};
+
+/* Convenience macros */
+#define hid_get_g19data(hdev) \
+	((struct g19_data *)(hid_get_drvdata(hdev)))
+
+#define input_get_hdev(idev) \
+	((struct hid_device *)(input_get_drvdata(idev)))
+
+#define input_get_g19data(idev) (hid_get_g19data(input_get_hdev(idev)))
+
+/*
+ * Keymap array indices
+ *
+ * Key        Index
+ * ---------  ------
+ * G1-G12     0-11
+ * M1         12
+ * M2         13
+ * M3         14
+ * MR         15
+ * LIGHT      19
+ */
+static const unsigned int g19_default_key_map[G19_KEYS] = {
+/*
+  KEY_F1, KEY_F2, KEY_F3, KEY_F4,
+  KEY_F5, KEY_F6, KEY_F7, KEY_F8,
+  KEY_F9, KEY_F10, KEY_F11, KEY_F12,
+*/
+  KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,
+  KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,
+  KEY_RESERVED, KEY_RESERVED, KEY_RESERVED, KEY_RESERVED,
+  /* M1, M2, M3, MR */
+  KEY_F21, KEY_F22, KEY_F23, KEY_F24,
+  KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_KBDILLUMTOGGLE,
+  KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN, KEY_UNKNOWN,
+
+/* Screen keymap
+ *
+ * Key   Index
+ * ----- -----
+ * Gear  0
+ * Back  1
+ * Menu  2
+ * OK    3
+ * Right 4
+ * Left  5
+ * Down  6
+ * Up    7
+ */
+
+
+  KEY_FORWARD, KEY_BACK, KEY_MENU, KEY_OK,
+  KEY_RIGHT, KEY_LEFT, KEY_DOWN, KEY_UP,
+};
+
+
+static DEVICE_ATTR(fb_node, 0444, gfb_fb_node_show, NULL);
+
+static DEVICE_ATTR(fb_update_rate, 0666,
+		   gfb_fb_update_rate_show,
+		   gfb_fb_update_rate_store);
+
+
+static void g19_led_send(struct hid_device *hdev)
+{
+	struct g19_data *data = hid_get_g19data(hdev);
+
+	data->led_report->field[0]->value[0] = data->led&0xFF;
+
+	usbhid_submit_report(hdev, data->led_report, USB_DIR_OUT);
+}
+
+static void g19_led_set(struct led_classdev *led_cdev,
+			 enum led_brightness value,
+			 int led_num)
+{
+	struct device *dev;
+	struct hid_device *hdev;
+	struct g19_data *data;
+	u8 mask;
+
+	/* Get the device associated with the led */
+	dev = led_cdev->dev->parent;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* Get the underlying data value */
+	data = hid_get_g19data(hdev);
+
+	mask = 0x80>>led_num;
+	if (value)
+		data->led |= mask;
+	else
+		data->led &= ~mask;
+
+	g19_led_send(hdev);
+}
+
+static void g19_led_m1_brightness_set(struct led_classdev *led_cdev,
+				      enum led_brightness value)
+{
+	g19_led_set(led_cdev, value, G19_LED_M1);
+}
+
+static void g19_led_m2_brightness_set(struct led_classdev *led_cdev,
+				      enum led_brightness value)
+{
+	g19_led_set(led_cdev, value, G19_LED_M2);
+}
+
+static void g19_led_m3_brightness_set(struct led_classdev *led_cdev,
+				      enum led_brightness value)
+{
+	g19_led_set(led_cdev, value, G19_LED_M3);
+}
+
+static void g19_led_mr_brightness_set(struct led_classdev *led_cdev,
+				      enum led_brightness value)
+{
+	g19_led_set(led_cdev, value, G19_LED_MR);
+}
+
+static enum led_brightness g19_led_brightness_get(struct led_classdev *led_cdev)
+{
+	struct device *dev;
+	struct hid_device *hdev;
+	struct g19_data *data;
+	int value = 0;
+
+	/* Get the device associated with the led */
+	dev = led_cdev->dev->parent;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* Get the underlying data value */
+	data = hid_get_g19data(hdev);
+
+	if (led_cdev == data->led_cdev[G19_LED_M1])
+		value = data->led & 0x80;
+	else if (led_cdev == data->led_cdev[G19_LED_M2])
+		value = data->led & 0x40;
+	else if (led_cdev == data->led_cdev[G19_LED_M3])
+		value = data->led & 0x20;
+	else if (led_cdev == data->led_cdev[G19_LED_MR])
+		value = data->led & 0x10;
+	else
+		dev_info(dev, G19_NAME " error retrieving LED brightness\n");
+
+	if (value)
+		return LED_FULL;
+	return LED_OFF;
+}
+
+static void g19_rgb_send(struct hid_device *hdev)
+{
+	struct g19_data *data = hid_get_g19data(hdev);
+
+	data->backlight_report->field[0]->value[0] = data->rgb[0];
+	data->backlight_report->field[0]->value[1] = data->rgb[1];
+	data->backlight_report->field[0]->value[2] = data->rgb[2];
+
+	usbhid_submit_report(hdev, data->backlight_report, USB_DIR_OUT);
+}
+
+static void g19_led_bl_brightness_set(struct led_classdev *led_cdev,
+				      int value)
+{
+	struct device *dev;
+	struct hid_device *hdev;
+	struct g19_data *data;
+
+	/* Get the device associated with the led */
+	dev = led_cdev->dev->parent;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* Get the underlying data value */
+	data = hid_get_g19data(hdev);
+
+	if (led_cdev == data->led_cdev[G19_LED_BL_R])
+		data->rgb[0] = value;
+	else if (led_cdev == data->led_cdev[G19_LED_BL_G])
+		data->rgb[1] = value;
+	else if (led_cdev == data->led_cdev[G19_LED_BL_B])
+		data->rgb[2] = value;
+
+	g19_rgb_send(hdev);
+}
+
+static int g19_led_bl_brightness_get(struct led_classdev *led_cdev)
+{
+	struct device *dev;
+	struct hid_device *hdev;
+	struct g19_data *data;
+
+	/* Get the device associated with the led */
+	dev = led_cdev->dev->parent;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* Get the underlying data value */
+	data = hid_get_g19data(hdev);
+
+	if (led_cdev == data->led_cdev[G19_LED_BL_R])
+		return data->rgb[0];
+	else if (led_cdev == data->led_cdev[G19_LED_BL_G])
+		return data->rgb[1];
+	else if (led_cdev == data->led_cdev[G19_LED_BL_B])
+		return data->rgb[2];
+	else
+		dev_info(dev, G19_NAME " error retrieving LED brightness\n");
+	return 0;
+}
+
+
+static const struct led_classdev g19_led_cdevs[7] = {
+	{
+		.brightness_set		= g19_led_m1_brightness_set,
+		.brightness_get		= g19_led_brightness_get,
+	},
+	{
+		.brightness_set		= g19_led_m2_brightness_set,
+		.brightness_get		= g19_led_brightness_get,
+	},
+	{
+		.brightness_set		= g19_led_m3_brightness_set,
+		.brightness_get		= g19_led_brightness_get,
+	},
+	{
+		.brightness_set		= g19_led_mr_brightness_set,
+		.brightness_get		= g19_led_brightness_get,
+	},
+	{
+		.brightness_set		= g19_led_bl_brightness_set,
+		.brightness_get		= g19_led_bl_brightness_get,
+	},
+	{
+		.brightness_set		= g19_led_bl_brightness_set,
+		.brightness_get		= g19_led_bl_brightness_get,
+	},
+	{
+		.brightness_set		= g19_led_bl_brightness_set,
+		.brightness_get		= g19_led_bl_brightness_get,
+	},
+};
+
+static int g19_input_setkeycode(struct input_dev *dev,
+				int scancode,
+				int keycode)
+{
+	int old_keycode;
+	int i;
+	struct g19_data *data = input_get_g19data(dev);
+
+	if (scancode >= dev->keycodemax)
+		return -EINVAL;
+
+	spin_lock(&data->lock);
+
+	old_keycode = data->keycode[scancode];
+	data->keycode[scancode] = keycode;
+
+	__clear_bit(old_keycode, dev->keybit);
+	__set_bit(keycode, dev->keybit);
+
+	for (i = 0; i < dev->keycodemax; i++) {
+		if (data->keycode[i] == old_keycode) {
+			__set_bit(old_keycode, dev->keybit);
+			break; /* Setting the bit twice is useless, so break*/
+		}
+	}
+
+	spin_unlock(&data->lock);
+
+	return 0;
+}
+
+static int g19_input_getkeycode(struct input_dev *dev,
+				int scancode,
+				int *keycode)
+{
+	struct g19_data *data = input_get_g19data(dev);
+
+	if (!dev->keycodesize)
+		return -EINVAL;
+
+	if (scancode >= dev->keycodemax)
+		return -EINVAL;
+
+	*keycode = data->keycode[scancode];
+
+	return 0;
+}
+
+
+/*
+ * The "keymap" attribute
+ */
+static ssize_t g19_keymap_index_show(struct device *dev,
+				     struct device_attribute *attr,
+				     char *buf)
+{
+	struct g19_data *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", data->curkeymap);
+}
+
+static ssize_t g19_set_keymap_index(struct hid_device *hdev, unsigned k)
+{
+	int scancode;
+	int offset_old;
+	int offset_new;
+	int keycode_old;
+	int keycode_new;
+	struct g19_data *data = hid_get_g19data(hdev);
+	struct input_dev *idev = data->input_dev;
+
+	if (k > 2)
+		return -EINVAL;
+
+	/*
+	 * Release all the pressed keys unless the new keymap has the same key
+	 * in the same scancode position.
+	 *
+	 * Also, clear the scancode state unless the new keymap has the same
+	 * key in the same scancode position.
+	 *
+	 * This allows a keycode mapped to the same scancode in two different
+	 * keymaps to remain pressed without a key up code when the keymap is
+	 * switched.
+	 */
+	offset_old = G19_KEYS * data->curkeymap;
+	offset_new = G19_KEYS * k;
+	for (scancode = 0; scancode < G19_KEYS; scancode++) {
+		keycode_old = data->keycode[offset_old+scancode];
+		keycode_new = data->keycode[offset_new+scancode];
+		if (keycode_old != keycode_new) {
+			if (keycode_old != KEY_RESERVED)
+				input_report_key(idev, keycode_old, 0);
+			data->scancode_state[scancode] = 0;
+		}
+	}
+
+	data->curkeymap = k;
+
+	if (data->keymap_switching) {
+		data->led = 1 << k;
+		g19_led_send(hdev);
+	}
+
+	return 0;
+}
+
+static ssize_t g19_keymap_index_store(struct device *dev,
+				      struct device_attribute *attr,
+				      const char *buf, size_t count)
+{
+	struct hid_device *hdev;
+	int i;
+	unsigned k;
+	ssize_t set_result;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* If we have an invalid pointer we'll return ENODATA */
+	if (hdev == NULL || &(hdev->dev) != dev)
+		return -ENODATA;
+
+	i = sscanf(buf, "%u", &k);
+	if (i != 1) {
+		dev_warn(dev, G19_NAME " unrecognized input: %s", buf);
+		return -1;
+	}
+
+	set_result = g19_set_keymap_index(hdev, k);
+
+	if (set_result < 0)
+		return set_result;
+
+	return count;
+}
+
+static DEVICE_ATTR(keymap_index, 0666,
+		   g19_keymap_index_show,
+		   g19_keymap_index_store);
+
+/*
+ * The "keycode" attribute
+ */
+static ssize_t g19_keymap_show(struct device *dev,
+			       struct device_attribute *attr,
+			       char *buf)
+{
+	int offset = 0;
+	int result;
+	int scancode;
+	int keycode;
+	int error;
+
+	struct g19_data *data = dev_get_drvdata(dev);
+
+	for (scancode = 0; scancode < G19_KEYMAP_SIZE; scancode++) {
+		error = input_get_keycode(data->input_dev, scancode, &keycode);
+		if (error) {
+			dev_warn(dev, G19_NAME " error accessing scancode %d\n",
+				 scancode);
+			continue;
+		}
+
+		result = sprintf(buf+offset, "0x%03x 0x%04x\n",
+				 scancode, keycode);
+		if (result < 0)
+			return -EINVAL;
+		offset += result;
+	}
+
+	return offset+1;
+}
+
+static ssize_t g19_keymap_store(struct device *dev,
+				struct device_attribute *attr,
+				const char *buf, size_t count)
+{
+	struct hid_device *hdev;
+	int scanned;
+	int consumed;
+	int scancd;
+	int keycd;
+	int error;
+	int set = 0;
+	int gkey;
+	int index;
+	int good;
+	struct g19_data *data;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* If we have an invalid pointer we'll return ENODATA */
+	if (hdev == NULL || &(hdev->dev) != dev)
+		return -ENODATA;
+
+	/* Now, let's get the data structure */
+	data = hid_get_g19data(hdev);
+
+	do {
+		good = 0;
+
+		/* Look for scancode keycode pair in hex */
+		scanned = sscanf(buf, "%x %x%n", &scancd, &keycd, &consumed);
+		if (scanned == 2) {
+			buf += consumed;
+			error = g19_input_setkeycode(data->input_dev, scancd, keycd);
+			if (error)
+				goto err_input_setkeycode;
+			set++;
+			good = 1;
+		} else {
+			/*
+			 * Look for Gkey keycode pair and assign to current
+			 * keymap
+			 */
+			scanned = sscanf(buf, "G%d %x%n", &gkey, &keycd, &consumed);
+			if (scanned == 2 && gkey > 0 && gkey <= G19_KEYS) {
+				buf += consumed;
+				scancd = data->curkeymap * G19_KEYS + gkey - 1;
+				error = g19_input_setkeycode(data->input_dev, scancd, keycd);
+				if (error)
+					goto err_input_setkeycode;
+				set++;
+				good = 1;
+			} else {
+				/*
+				 * Look for Gkey-index keycode pair and assign
+				 * to indexed keymap
+				 */
+				scanned = sscanf(buf, "G%d-%d %x%n", &gkey, &index, &keycd, &consumed);
+				if (scanned == 3 &&
+				    gkey > 0 && gkey <= G19_KEYS &&
+				    index >= 0 && index <= 2) {
+					buf += consumed;
+					scancd = index * G19_KEYS + gkey - 1;
+					error = g19_input_setkeycode(data->input_dev, scancd, keycd);
+					if (error)
+						goto err_input_setkeycode;
+					set++;
+					good = 1;
+				}
+			}
+		}
+
+	} while (good);
+
+	if (set == 0) {
+		dev_warn(dev, G19_NAME " unrecognized keycode input: %s", buf);
+		return -1;
+	}
+
+	return count;
+
+err_input_setkeycode:
+	dev_warn(dev, G19_NAME " error setting scancode %d to keycode %d\n",
+		 scancd, keycd);
+	return error;
+}
+
+static DEVICE_ATTR(keymap, 0666, g19_keymap_show, g19_keymap_store);
+
+/*
+ * The "keymap_switching" attribute
+ */
+static ssize_t g19_keymap_switching_show(struct device *dev,
+					 struct device_attribute *attr,
+					 char *buf)
+{
+	struct g19_data *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%u\n", data->keymap_switching);
+}
+
+static ssize_t g19_set_keymap_switching(struct hid_device *hdev, unsigned k)
+{
+	struct g19_data *data = hid_get_g19data(hdev);
+
+	data->keymap_switching = k;
+
+	if (data->keymap_switching) {
+		data->led = 1 << data->curkeymap;
+		g19_led_send(hdev);
+	}
+
+	return 0;
+}
+
+static ssize_t g19_keymap_switching_store(struct device *dev,
+					  struct device_attribute *attr,
+					  const char *buf, size_t count)
+{
+	struct hid_device *hdev;
+	int i;
+	unsigned k;
+	ssize_t set_result;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* If we have an invalid pointer we'll return ENODATA */
+	if (hdev == NULL || &(hdev->dev) != dev)
+		return -ENODATA;
+
+	i = sscanf(buf, "%u", &k);
+	if (i != 1) {
+		dev_warn(dev, G19_NAME "unrecognized input: %s", buf);
+		return -1;
+	}
+
+	set_result = g19_set_keymap_switching(hdev, k);
+
+	if (set_result < 0)
+		return set_result;
+
+	return count;
+}
+
+static DEVICE_ATTR(keymap_switching, 0644,
+		   g19_keymap_switching_show,
+		   g19_keymap_switching_store);
+
+
+static ssize_t g19_name_show(struct device *dev,
+			     struct device_attribute *attr,
+			     char *buf)
+{
+	struct g19_data *data = dev_get_drvdata(dev);
+	int result;
+
+	if (data->name == NULL) {
+		buf[0] = 0x00;
+		return 1;
+	}
+
+	spin_lock(&data->lock);
+	result = sprintf(buf, "%s", data->name);
+	spin_unlock(&data->lock);
+
+	return result;
+}
+
+static ssize_t g19_name_store(struct device *dev,
+			      struct device_attribute *attr,
+			      const char *buf, size_t count)
+{
+	struct g19_data *data = dev_get_drvdata(dev);
+	size_t limit = count;
+	char *end;
+
+	spin_lock(&data->lock);
+
+	if (data->name != NULL) {
+		kfree(data->name);
+		data->name = NULL;
+	}
+
+	end = strpbrk(buf, "\n\r");
+	if (end != NULL)
+		limit = end - buf;
+
+	if (end != buf) {
+
+		if (limit > 100)
+			limit = 100;
+
+		data->name = kzalloc(limit+1, GFP_ATOMIC);
+
+		strncpy(data->name, buf, limit);
+	}
+
+	spin_unlock(&data->lock);
+
+	return count;
+}
+
+static DEVICE_ATTR(name, 0666, g19_name_show, g19_name_store);
+
+static void g19_feature_report_4_send(struct hid_device *hdev, int which)
+{
+	struct g19_data *data = hid_get_g19data(hdev);
+
+	if (which == G19_REPORT_4_INIT) {
+		data->feature_report_4->field[0]->value[0] = 0x02;
+		data->feature_report_4->field[0]->value[1] = 0x00;
+		data->feature_report_4->field[0]->value[2] = 0x00;
+		data->feature_report_4->field[0]->value[3] = 0x00;
+	} else if (which == G19_REPORT_4_FINALIZE) {
+		data->feature_report_4->field[0]->value[0] = 0x02;
+		data->feature_report_4->field[0]->value[1] = 0x80;
+		data->feature_report_4->field[0]->value[2] = 0x00;
+		data->feature_report_4->field[0]->value[3] = 0xFF;
+	} else {
+		return;
+	}
+
+	usbhid_submit_report(hdev, data->feature_report_4, USB_DIR_OUT);
+}
+
+/*
+ * The "minor" attribute
+ */
+static ssize_t g19_minor_show(struct device *dev,
+			      struct device_attribute *attr,
+			      char *buf)
+{
+	struct g19_data *data = dev_get_drvdata(dev);
+
+	return sprintf(buf, "%d\n", data->hdev->minor);
+}
+
+static DEVICE_ATTR(minor, 0444, g19_minor_show, NULL);
+
+/*
+ * Create a group of attributes so that we can create and destroy them all
+ * at once.
+ */
+static struct attribute *g19_attrs[] = {
+	&dev_attr_name.attr,
+	&dev_attr_keymap_index.attr,
+	&dev_attr_keymap_switching.attr,
+	&dev_attr_keymap.attr,
+	&dev_attr_minor.attr,
+	&dev_attr_fb_update_rate.attr,
+	&dev_attr_fb_node.attr,
+	NULL,	 /* need to NULL terminate the list of attributes */
+};
+
+/*
+ * An unnamed attribute group will put all of the attributes directly in
+ * the kobject directory.  If we specify a name, a subdirectory will be
+ * created for the attributes with the directory being the name of the
+ * attribute group.
+ */
+static struct attribute_group g19_attr_group = {
+	.attrs = g19_attrs,
+};
+
+
+
+static void g19_handle_key_event(struct g19_data *data,
+				 struct input_dev *idev,
+				 int scancode,
+				 int value)
+{
+	int error;
+	int keycode;
+	int offset;
+
+	offset = G19_KEYS * data->curkeymap;
+
+	error = input_get_keycode(idev, scancode+offset, &keycode);
+
+	if (unlikely(error)) {
+		dev_warn(&idev->dev, G19_NAME " error in input_get_keycode(): scancode=%d\n", scancode);
+		return;
+	}
+
+	/* Only report mapped keys */
+	if (keycode != KEY_RESERVED)
+		input_report_key(idev, keycode, value);
+	/* Or report MSC_SCAN on keypress of an unmapped key */
+/*	else if (data->scancode_state[scancode] == 0 && value)
+		input_event(idev, EV_MSC, MSC_SCAN, scancode);
+*/
+	data->scancode_state[scancode] = value;
+}
+
+static void g19_raw_event_process_input(struct hid_device *hdev,
+					struct g19_data *data,
+					u8 *raw_data)
+{
+	struct input_dev *idev = data->input_dev;
+	int scancode;
+	int value;
+	int i;
+	int mask;
+
+	/*
+	 * We'll check for the M* keys being pressed before processing
+	 * the remainder of the key data. That way the new keymap will
+	 * be loaded if there is a keymap switch.
+	 */
+/*
+	if (unlikely(data->keymap_switching)) {
+		if (data->curkeymap != 0 && raw_data[2] & 0x10)
+			g19_set_keymap_index(hdev, 0);
+		else if (data->curkeymap != 1 && raw_data[2] & 0x20)
+			g19_set_keymap_index(hdev, 1);
+		else if (data->curkeymap != 2 && raw_data[2] & 0x40)
+			g19_set_keymap_index(hdev, 2);
+	}
+*/
+	raw_data[3] &= 0xBF; /* bit 6 is always on */
+
+	for (i = 0, mask = 0x01; i < 8; i++, mask <<= 1) {
+		/* Keys G1 through G8 */
+		scancode = i;
+		value = raw_data[1] & mask;
+		g19_handle_key_event(data, idev, scancode, value);
+
+		/* Keys G9 through G16 */
+		scancode = i + 8;
+		value = raw_data[2] & mask;
+		g19_handle_key_event(data, idev, scancode, value);
+
+		/* Keys G17 through G22 */
+		scancode = i + 16;
+		value = raw_data[3] & mask;
+		g19_handle_key_event(data, idev, scancode, value);
+
+	}
+
+	input_sync(idev);
+}
+
+static int g19_raw_event(struct hid_device *hdev,
+			 struct hid_report *report,
+			 u8 *raw_data, int size)
+{
+	/*
+	* On initialization receive a 258 byte message with
+	* data = 6 0 255 255 255 255 255 255 255 255 ...
+	*/
+	struct g19_data *data;
+	data = dev_get_drvdata(&hdev->dev);
+
+	spin_lock(&data->lock);
+
+	if (unlikely(data->need_reset)) {
+		g19_rgb_send(hdev);
+		g19_led_send(hdev);
+		data->need_reset = 0;
+		spin_unlock(&data->lock);
+		return 1;
+	}
+
+	if (unlikely(data->ready_stages != G19_READY_STAGE_3)) {
+		switch (report->id) {
+		case 6:
+			if (!(data->ready_stages & G19_READY_SUBSTAGE_1))
+				data->ready_stages |= G19_READY_SUBSTAGE_1;
+			else if (data->ready_stages & G19_READY_SUBSTAGE_4 &&
+				 !(data->ready_stages & G19_READY_SUBSTAGE_5)
+				)
+				data->ready_stages |= G19_READY_SUBSTAGE_5;
+			else if (data->ready_stages & G19_READY_SUBSTAGE_6 &&
+				 raw_data[1] >= 0x80)
+				data->ready_stages |= G19_READY_SUBSTAGE_7;
+			break;
+		case 1:
+			if (!(data->ready_stages & G19_READY_SUBSTAGE_2))
+				data->ready_stages |= G19_READY_SUBSTAGE_2;
+			else
+				data->ready_stages |= G19_READY_SUBSTAGE_3;
+			break;
+		}
+
+		if (data->ready_stages == G19_READY_STAGE_1 ||
+		    data->ready_stages == G19_READY_STAGE_2 ||
+		    data->ready_stages == G19_READY_STAGE_3)
+			complete_all(&data->ready);
+
+		spin_unlock(&data->lock);
+		return 1;
+	}
+
+	spin_unlock(&data->lock);
+
+	if (likely(report->id == 2)) {
+		g19_raw_event_process_input(hdev, data, raw_data);
+		return 1;
+	}
+
+	return 0;
+}
+
+static void g19_initialize_keymap(struct g19_data *data)
+{
+	int i;
+
+	for (i = 0; i < G19_KEYS; i++) {
+		data->keycode[i] = g19_default_key_map[i];
+		__set_bit(data->keycode[i], data->input_dev->keybit);
+	}
+
+	__clear_bit(KEY_RESERVED, data->input_dev->keybit);
+}
+
+/* Unlock the urb so we can reuse it */
+static void g19_ep1_urb_completion(struct urb *urb)
+{
+	struct hid_device *hdev = urb->context;
+	struct g19_data *data = hid_get_g19data(hdev);
+	struct input_dev *idev = data->input_dev;
+	int i;
+
+	for (i = 0; i < 8; i++)
+		g19_handle_key_event(data, idev, 24+i, data->ep1keys[0]&(1<<i));
+
+	input_sync(idev);
+
+	usb_submit_urb(urb, GFP_ATOMIC);
+}
+
+static int g19_ep1_read(struct hid_device *hdev)
+{
+	struct usb_interface *intf;
+	struct usb_device *usb_dev;
+	struct g19_data *data = hid_get_g19data(hdev);
+
+	struct usb_host_endpoint *ep;
+	unsigned int pipe;
+	int retval = 0;
+
+	/* Get the usb device to send the image on */
+	intf = to_usb_interface(hdev->dev.parent);
+	usb_dev = interface_to_usbdev(intf);
+
+	pipe = usb_rcvintpipe(usb_dev, 0x01);
+	ep = (usb_pipein(pipe) ? usb_dev->ep_in : usb_dev->ep_out)[usb_pipeendpoint(pipe)];
+
+	if (unlikely(!ep))
+		return -EINVAL;
+
+	usb_fill_int_urb(data->ep1_urb, usb_dev, pipe, data->ep1keys, 2,
+			 g19_ep1_urb_completion, NULL, 10);
+	data->ep1_urb->context = hdev;
+	data->ep1_urb->actual_length = 0;
+
+	retval = usb_submit_urb(data->ep1_urb, GFP_KERNEL);
+
+	return retval;
+}
+
+
+
+static int g19_probe(struct hid_device *hdev,
+		     const struct hid_device_id *id)
+{
+	int error;
+	struct g19_data *data;
+	int i;
+	int led_num;
+	struct usb_interface *intf;
+	struct usb_device *usbdev;
+	struct list_head *feature_report_list =
+		&hdev->report_enum[HID_FEATURE_REPORT].report_list;
+	struct list_head *output_report_list =
+			&hdev->report_enum[HID_OUTPUT_REPORT].report_list;
+	struct hid_report *report;
+	char *led_name;
+
+	dev_dbg(&hdev->dev, "Logitech G19 HID hardware probe...");
+
+	/* Get the usb device to send the start report on */
+	intf = to_usb_interface(hdev->dev.parent);
+	usbdev = interface_to_usbdev(intf);
+
+	/*
+	 * Let's allocate the g19 data structure, set some reasonable
+	 * defaults, and associate it with the device
+	 */
+	data = kzalloc(sizeof(struct g19_data), GFP_KERNEL);
+	if (data == NULL) {
+		dev_err(&hdev->dev, "can't allocate space for Logitech G19 device attributes\n");
+		error = -ENOMEM;
+		goto err_no_cleanup;
+	}
+
+	spin_lock_init(&data->lock);
+
+	init_completion(&data->ready);
+
+	data->hdev = hdev;
+
+	data->ep1_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (data->ep1_urb == NULL) {
+		dev_err(&hdev->dev, G19_NAME ": ERROR: can't alloc ep1 urb stuff\n");
+		error = -ENOMEM;
+		goto err_cleanup_data;
+	}
+
+	hid_set_drvdata(hdev, data);
+
+	dbg_hid("Preparing to parse " G19_NAME " hid reports\n");
+
+	/* Parse the device reports and start it up */
+	error = hid_parse(hdev);
+	if (error) {
+		dev_err(&hdev->dev, G19_NAME " device report parse failed\n");
+		error = -EINVAL;
+		goto err_cleanup_ep1_urb;
+	}
+
+	error = hid_hw_start(hdev, HID_CONNECT_DEFAULT | HID_CONNECT_HIDINPUT_FORCE);
+	if (error) {
+		dev_err(&hdev->dev, G19_NAME " hardware start failed\n");
+		error = -EINVAL;
+		goto err_cleanup_ep1_urb;
+	}
+
+	dbg_hid(G19_NAME " claimed: %d\n", hdev->claimed);
+
+	error = hdev->ll_driver->open(hdev);
+	if (error) {
+		dev_err(&hdev->dev, G19_NAME " failed to open input interrupt pipe for key and joystick events\n");
+		error = -EINVAL;
+		goto err_cleanup_ep1_urb;
+	}
+
+	/* Set up the input device for the key I/O */
+	data->input_dev = input_allocate_device();
+	if (data->input_dev == NULL) {
+		dev_err(&hdev->dev, G19_NAME " error initializing the input device");
+		error = -ENOMEM;
+		goto err_cleanup_ep1_urb;
+	}
+
+	input_set_drvdata(data->input_dev, hdev);
+
+	data->input_dev->name = G19_NAME;
+	data->input_dev->phys = hdev->phys;
+	data->input_dev->uniq = hdev->uniq;
+	data->input_dev->id.bustype = hdev->bus;
+	data->input_dev->id.vendor = hdev->vendor;
+	data->input_dev->id.product = hdev->product;
+	data->input_dev->id.version = hdev->version;
+	data->input_dev->dev.parent = hdev->dev.parent;
+	data->input_dev->keycode = data->keycode;
+	data->input_dev->keycodemax = G19_KEYMAP_SIZE;
+	data->input_dev->keycodesize = sizeof(int);
+	data->input_dev->setkeycode = g19_input_setkeycode;
+	data->input_dev->getkeycode = g19_input_getkeycode;
+
+	input_set_capability(data->input_dev, EV_KEY, KEY_UNKNOWN);
+	data->input_dev->evbit[0] |= BIT_MASK(EV_REP);
+
+	g19_initialize_keymap(data);
+
+	error = input_register_device(data->input_dev);
+	if (error) {
+		dev_err(&hdev->dev, G19_NAME " error registering the input device");
+		error = -EINVAL;
+		goto err_cleanup_input_dev;
+	}
+
+	if (list_empty(feature_report_list)) {
+		dev_err(&hdev->dev, "no feature report found\n");
+		error = -ENODEV;
+		goto err_cleanup_input_dev_reg;
+	}
+	dbg_hid(G19_NAME " feature report found\n");
+
+	list_for_each_entry(report, feature_report_list, list) {
+		switch (report->id) {
+		case 0x04:
+			data->feature_report_4 = report;
+			break;
+		case 0x05:
+			data->led_report = report;
+			break;
+		case 0x06:
+			data->start_input_report = report;
+			break;
+		case 0x07:
+			data->backlight_report = report;
+			break;
+		default:
+			break;
+		}
+		dbg_hid(G19_NAME " Feature report: id=%u type=%u size=%u maxfield=%u report_count=%u\n",
+			report->id, report->type, report->size,
+			report->maxfield, report->field[0]->report_count);
+	}
+
+	dbg_hid("Found all reports\n");
+
+	/* Create the LED structures */
+	for (i = 0; i < 7; i++) {
+		data->led_cdev[i] = kzalloc(sizeof(struct led_classdev), GFP_KERNEL);
+		if (data->led_cdev[i] == NULL) {
+			dev_err(&hdev->dev, G19_NAME " error allocating memory for led %d", i);
+			error = -ENOMEM;
+			goto err_cleanup_led_structs;
+		}
+		/* Set the accessor functions by copying from template*/
+		*(data->led_cdev[i]) = g19_led_cdevs[i];
+
+		/*
+		 * Allocate memory for the LED name
+		 *
+		 * Since led_classdev->name is a const char* we'll use an
+		 * intermediate until the name is formatted with sprintf().
+		 */
+		led_name = kzalloc(sizeof(char)*20, GFP_KERNEL);
+		if (led_name == NULL) {
+			dev_err(&hdev->dev, G19_NAME " error allocating memory for led %d name", i);
+			error = -ENOMEM;
+			goto err_cleanup_led_structs;
+		}
+		switch (i) {
+		case 0:
+		case 1:
+		case 2:
+			sprintf(led_name, "g19_%d:orange:m%d", hdev->minor, i+1);
+			break;
+		case 3:
+			sprintf(led_name, "g19_%d:red:mr", hdev->minor);
+			break;
+		case 4:
+			sprintf(led_name, "g19_%d:red:bl", hdev->minor);
+			break;
+		case 5:
+			sprintf(led_name, "g19_%d:green:bl", hdev->minor);
+			break;
+		case 6:
+			sprintf(led_name, "g19_%d:blue:bl", hdev->minor);
+			break;
+
+		}
+		data->led_cdev[i]->name = led_name;
+	}
+
+	for (i = 0; i < 7; i++) {
+		led_num = i;
+		error = led_classdev_register(&hdev->dev, data->led_cdev[i]);
+		if (error < 0) {
+			dev_err(&hdev->dev, G19_NAME " error registering led %d", i);
+			error = -EINVAL;
+			goto err_cleanup_registered_leds;
+		}
+	}
+
+	data->gfb_data = gfb_probe(hdev, GFB_PANEL_TYPE_320_240_16);
+	if (data->gfb_data == NULL) {
+		dev_err(&hdev->dev, G19_NAME " error registering framebuffer\n", i);
+		goto err_cleanup_registered_leds;
+	}
+
+	dbg_hid("Waiting for G19 to activate\n");
+
+	/* Add the sysfs attributes */
+	error = sysfs_create_group(&(hdev->dev.kobj), &g19_attr_group);
+	if (error) {
+		dev_err(&hdev->dev, G19_NAME " failed to create sysfs group attributes\n");
+		goto err_cleanup_registered_leds;
+	}
+
+	/*
+	 * Wait here for stage 1 (substages 1-3) to complete
+	 */
+	wait_for_completion_timeout(&data->ready, HZ);
+
+	/* Protect data->ready_stages before checking whether we're ready to proceed */
+	spin_lock(&data->lock);
+	if (data->ready_stages != G19_READY_STAGE_1) {
+		dev_warn(&hdev->dev, G19_NAME " hasn't completed stage 1 yet, forging ahead with initialization\n");
+		/* Force the stage */
+		data->ready_stages = G19_READY_STAGE_1;
+	}
+	init_completion(&data->ready);
+	data->ready_stages |= G19_READY_SUBSTAGE_4;
+	spin_unlock(&data->lock);
+
+	/*
+	 * Send the init report, then follow with the input report to trigger
+	 * report 6 and wait for us to get a response.
+	 */
+	g19_feature_report_4_send(hdev, G19_REPORT_4_INIT);
+	usbhid_submit_report(hdev, data->start_input_report, USB_DIR_IN);
+	wait_for_completion_timeout(&data->ready, HZ);
+
+	/* Protect data->ready_stages before checking whether we're ready to proceed */
+	spin_lock(&data->lock);
+	if (data->ready_stages != G19_READY_STAGE_2) {
+		dev_warn(&hdev->dev, G19_NAME " hasn't completed stage 2 yet, forging ahead with initialization\n");
+		/* Force the stage */
+		data->ready_stages = G19_READY_STAGE_2;
+	}
+	init_completion(&data->ready);
+	data->ready_stages |= G19_READY_SUBSTAGE_6;
+	spin_unlock(&data->lock);
+
+	/*
+	 * Clear the LEDs
+	 */
+	g19_led_send(hdev);
+
+	data->rgb[0] = G19_DEFAULT_RED;
+	data->rgb[1] = G19_DEFAULT_GREEN;
+	data->rgb[2] = G19_DEFAULT_BLUE;
+	g19_rgb_send(hdev);
+
+	/*
+	 * Send the finalize report, then follow with the input report to trigger
+	 * report 6 and wait for us to get a response.
+	 */
+	g19_feature_report_4_send(hdev, G19_REPORT_4_FINALIZE);
+	usbhid_submit_report(hdev, data->start_input_report, USB_DIR_IN);
+	usbhid_submit_report(hdev, data->start_input_report, USB_DIR_IN);
+	wait_for_completion_timeout(&data->ready, HZ);
+
+	/* Protect data->ready_stages before checking whether we're ready to proceed */
+	spin_lock(&data->lock);
+
+	if (data->ready_stages != G19_READY_STAGE_3) {
+		dev_warn(&hdev->dev, G19_NAME " hasn't completed stage 3 yet, forging ahead with initialization\n");
+		/* Force the stage */
+		data->ready_stages = G19_READY_STAGE_3;
+	} else {
+		dbg_hid(G19_NAME " stage 3 complete\n");
+	}
+
+	spin_unlock(&data->lock);
+
+	g19_set_keymap_switching(hdev, 1);
+
+	g19_ep1_read(hdev);
+
+	dbg_hid("G19 activated and initialized\n");
+
+	/* Everything went well */
+	return 0;
+
+err_cleanup_registered_leds:
+	for (i = 0; i < led_num; i++)
+		led_classdev_unregister(data->led_cdev[i]);
+
+err_cleanup_led_structs:
+	for (i = 0; i < 7; i++) {
+		if (data->led_cdev[i] != NULL) {
+			if (data->led_cdev[i]->name != NULL)
+				kfree(data->led_cdev[i]->name);
+			kfree(data->led_cdev[i]);
+		}
+	}
+
+err_cleanup_input_dev_reg:
+	input_unregister_device(data->input_dev);
+
+err_cleanup_input_dev:
+	input_free_device(data->input_dev);
+
+err_cleanup_ep1_urb:
+	usb_free_urb(data->ep1_urb);
+
+
+
+err_cleanup_data:
+	/* Make sure we clean up the allocated data structure */
+	kfree(data);
+
+err_no_cleanup:
+
+	hid_set_drvdata(hdev, NULL);
+
+	return error;
+}
+
+static void g19_remove(struct hid_device *hdev)
+{
+	struct g19_data *data;
+	int i;
+
+	hdev->ll_driver->close(hdev);
+
+	hid_hw_stop(hdev);
+
+	sysfs_remove_group(&(hdev->dev.kobj), &g19_attr_group);
+
+	/* Get the internal g19 data buffer */
+	data = hid_get_drvdata(hdev);
+
+	input_unregister_device(data->input_dev);
+
+	kfree(data->name);
+
+	/* Clean up the leds */
+	for (i = 0; i < 7; i++) {
+		led_classdev_unregister(data->led_cdev[i]);
+		kfree(data->led_cdev[i]->name);
+		kfree(data->led_cdev[i]);
+	}
+
+	gfb_remove(data->gfb_data);
+
+	usb_free_urb(data->ep1_urb);
+
+
+	/* Finally, clean up the g19 data itself */
+	kfree(data);
+}
+
+static void g19_post_reset_start(struct hid_device *hdev)
+{
+	struct g19_data *data = hid_get_g19data(hdev);
+
+	spin_lock(&data->lock);
+	data->need_reset = 1;
+	spin_unlock(&data->lock);
+}
+
+static const struct hid_device_id g19_devices[] = {
+	{ HID_USB_DEVICE(USB_VENDOR_ID_LOGITECH, USB_DEVICE_ID_LOGITECH_G19_LCD)
+	},
+	{ }
+};
+MODULE_DEVICE_TABLE(hid, g19_devices);
+
+static struct hid_driver g19_driver = {
+	.name			= "hid-g19",
+	.id_table		= g19_devices,
+	.probe			= g19_probe,
+	.remove			= g19_remove,
+	.raw_event		= g19_raw_event,
+};
+
+static int __init g19_init(void)
+{
+	return hid_register_driver(&g19_driver);
+}
+
+static void __exit g19_exit(void)
+{
+	hid_unregister_driver(&g19_driver);
+}
+
+module_init(g19_init);
+module_exit(g19_exit);
+MODULE_DESCRIPTION("Logitech G19 HID Driver");
+MODULE_AUTHOR("Alistair Buxton (a.j.buxton@gmail.com)");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hid/hid-gfb.c b/drivers/hid/hid-gfb.c
new file mode 100644
index 0000000..173c2b4
--- /dev/null
+++ b/drivers/hid/hid-gfb.c
@@ -0,0 +1,568 @@
+/***************************************************************************
+ *   Copyright (C) 2010 by Alistair Buxton                                 *
+ *   a.j.buxton@gmail.com                                                  *
+ *   based on hid-g13.c                                                    *
+ *                                                                         *
+ *   This program is free software: you can redistribute it and/or modify  *
+ *   it under the terms of the GNU General Public License as published by  *
+ *   the Free Software Foundation, either version 2 of the License, or     *
+ *   (at your option) any later version.                                   *
+ *                                                                         *
+ *   This driver is distributed in the hope that it will be useful, but    *
+ *   WITHOUT ANY WARRANTY; without even the implied warranty of            *
+ *   MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU      *
+ *   General Public License for more details.                              *
+ *                                                                         *
+ *   You should have received a copy of the GNU General Public License     *
+ *   along with this software. If not see <http://www.gnu.org/licenses/>.  *
+ ***************************************************************************/
+#include <linux/fb.h>
+#include <linux/hid.h>
+#include <linux/init.h>
+#include <linux/input.h>
+#include <linux/mm.h>
+#include <linux/sysfs.h>
+#include <linux/uaccess.h>
+#include <linux/usb.h>
+#include <linux/vmalloc.h>
+#include <linux/leds.h>
+#include <linux/completion.h>
+
+#include "hid-ids.h"
+#include "usbhid/usbhid.h"
+
+#include "hid-gfb.h"
+
+#define GFB_NAME "Logitech GamePanel Framebuffer"
+
+/* Framebuffer defines */
+#define GFB_UPDATE_RATE_LIMIT (30)
+#define GFB_UPDATE_RATE_DEFAULT (30)
+
+/* Convenience macros */
+#define hid_get_gfbdata(hdev) \
+	((struct gfb_data *)(hid_get_drvdata(hdev)))
+
+/* Unlock the urb so we can reuse it */
+static void gfb_fb_urb_completion(struct urb *urb)
+{
+	struct gfb_data *data = urb->context;
+	spin_unlock(&data->fb_urb_lock);
+}
+
+/* Send the current framebuffer vbitmap as an interrupt message */
+static int gfb_fb_send(struct gfb_data *data)
+{
+	struct usb_interface *intf;
+	struct usb_device *usb_dev;
+	struct hid_device *hdev = data->hdev;
+
+	struct usb_host_endpoint *ep;
+	unsigned int pipe;
+	int retval = 0;
+
+	/*
+	 * Try and lock the framebuffer urb to prevent access if we have
+	 * submitted it. If we can't lock it we'll have to delay this update
+	 * until the next framebuffer interval.
+	 *
+	 * Fortunately, we already have the infrastructure in place with the
+	 * framebuffer deferred I/O driver to schedule the delayed update.
+	 */
+
+	if (likely(spin_trylock(&data->fb_urb_lock))) {
+		/* Get the usb device to send the image on */
+		intf = to_usb_interface(hdev->dev.parent);
+		usb_dev = interface_to_usbdev(intf);
+
+		switch (data->panel_type) {
+		case GFB_PANEL_TYPE_160_43_1:
+			pipe = usb_sndintpipe(usb_dev, 0x02);
+			break;
+		case GFB_PANEL_TYPE_320_240_16:
+			pipe = usb_sndbulkpipe(usb_dev, 0x02);
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		ep = (usb_pipein(pipe) ? usb_dev->ep_in : usb_dev->ep_out)[usb_pipeendpoint(pipe)];
+
+		if (unlikely(!ep)) {
+			spin_unlock(&data->fb_urb_lock);
+			return -EINVAL;
+		}
+
+		switch (data->panel_type) {
+		case GFB_PANEL_TYPE_160_43_1:
+			usb_fill_int_urb(data->fb_urb, usb_dev, pipe, data->fb_vbitmap, data->vbitmap_size,
+				 gfb_fb_urb_completion, NULL, ep->desc.bInterval);
+			break;
+		case GFB_PANEL_TYPE_320_240_16:
+			usb_fill_bulk_urb(data->fb_urb, usb_dev, pipe, data->fb_vbitmap, data->vbitmap_size,
+				 gfb_fb_urb_completion, NULL);
+			break;
+		default:
+			return -EINVAL;
+		}
+
+		data->fb_urb->context = data;
+		data->fb_urb->actual_length = 0;
+
+		retval = usb_submit_urb(data->fb_urb, GFP_NOIO);
+		if (unlikely(retval < 0)) {
+			/*
+			 * We need to unlock the framebuffer urb lock since
+			 * the urb submission failed and therefore
+			 * g19_fb_urb_completion() won't be called.
+			 */
+			spin_unlock(&data->fb_urb_lock);
+			return retval;
+		}
+	} else {
+		schedule_delayed_work(&data->fb_info->deferred_work, data->fb_defio.delay);
+	}
+
+	return retval;
+}
+
+
+char hdata[512] = {
+0x10, 0x0f, 0x00, 0x58, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x3f, 0x01, 0xef, 0x00, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff, 0x00, 0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08, 0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10, 0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18, 0x19, 0x1a, 0x1b, 0x1c, 0x1d, 0x1e, 0x1f, 0x20, 0x21, 0x22, 0x23, 0x24, 0x25, 0x26, 0x27, 0x28, 0x29, 0x2a, 0x2b, 0x2c, 0x2d, 0x2e, 0x2f, 0x30, 0x31, 0x32, 0x33, 0x34, 0x35, 0x36, 0x37, 0x38, 0x39, 0x3a, 0x3b, 0x3c, 0x3d, 0x3e, 0x3f, 0x40, 0x41, 0x42, 0x43, 0x44, 0x45, 0x46, 0x47, 0x48, 0x49, 0x4a, 0x4b, 0x4c, 0x4d, 0x4e, 0x4f, 0x50, 0x51, 0x52, 0x53, 0x54, 0x55, 0x56, 0x57, 0x58, 0x59, 0x5a, 0x5b, 0x5c, 0x5d, 0x5e, 0x5f, 0x60, 0x61, 0x62, 0x63, 0x64, 0x65, 0x66, 0x67, 0x68, 0x69, 0x6a, 0x6b, 0x6c, 0x6d, 0x6e, 0x6f, 0x70, 0x71, 0x72, 0x73, 0x74, 0x75, 0x76, 0x77, 0x78, 0x79, 0x7a, 0x7b, 0x7c, 0x7d, 0x7e, 0x7f, 0x80, 0x81, 0x82, 0x83, 0x84, 0x85, 0x86, 0x87, 0x88, 0x89, 0x8a, 0x8b, 0x8c, 0x8d, 0x8e, 0x8f, 0x90, 0x91, 0x92, 0x93, 0x94, 0x95, 0x96, 0x97, 0x98, 0x99, 0x9a, 0x9b, 0x9c, 0x9d, 0x9e, 0x9f, 0xa0, 0xa1, 0xa2, 0xa3, 0xa4, 0xa5, 0xa6, 0xa7, 0xa8, 0xa9, 0xaa, 0xab, 0xac, 0xad, 0xae, 0xaf, 0xb0, 0xb1, 0xb2, 0xb3, 0xb4, 0xb5, 0xb6, 0xb7, 0xb8, 0xb9, 0xba, 0xbb, 0xbc, 0xbd, 0xbe, 0xbf, 0xc0, 0xc1, 0xc2, 0xc3, 0xc4, 0xc5, 0xc6, 0xc7, 0xc8, 0xc9, 0xca, 0xcb, 0xcc, 0xcd, 0xce, 0xcf, 0xd0, 0xd1, 0xd2, 0xd3, 0xd4, 0xd5, 0xd6, 0xd7, 0xd8, 0xd9, 0xda, 0xdb, 0xdc, 0xdd, 0xde, 0xdf, 0xe0, 0xe1, 0xe2, 0xe3, 0xe4, 0xe5, 0xe6, 0xe7, 0xe8, 0xe9, 0xea, 0xeb, 0xec, 0xed, 0xee, 0xef, 0xf0, 0xf1, 0xf2, 0xf3, 0xf4, 0xf5, 0xf6, 0xf7, 0xf8, 0xf9, 0xfa, 0xfb, 0xfc, 0xfd, 0xfe, 0xff};
+
+/* Update fb_vbitmap from the screen_base and send to the device */
+static void gfb_fb_qvga_update(struct gfb_data *data)
+{
+	int row;
+	int col;
+	int x, y;
+	u16 *src, *dst;
+
+	/* Clear the vbitmap and set the necessary magic number */
+	memset(data->fb_vbitmap, 0x00, data->vbitmap_size);
+	memcpy(data->fb_vbitmap, &hdata, sizeof(hdata));
+
+	/* LCD is a portrait mode one so we have to rotate the framebuffer */
+
+	src = (u16 *)data->fb_bitmap;
+	dst = (u16 *)(data->fb_vbitmap+512);
+
+	x = data->fb_info->var.xres;
+	y = data->fb_info->var.yres;
+	for (col = 0; col < x; col++)
+		for (row = 0; row < y; row++)
+			*dst++ = *(src+col+(row*x));
+
+
+	/*
+	 * Now that we have translated screen_base into a format expected by
+	 * the gfb let's send out the vbitmap
+	 */
+	gfb_fb_send(data);
+
+}
+
+static void gfb_fb_mono_update(struct gfb_data *data)
+{
+	int row;
+	int col;
+	int bit;
+	int x, y, ll;
+	u8 *u;
+	size_t offset;
+	u8 temp;
+
+	/* Clear the vbitmap and set the necessary magic number */
+	memset(data->fb_vbitmap, 0x00, data->vbitmap_size);
+	data->fb_vbitmap[0] = 0x03;
+
+	/*
+	 * Translate the XBM format screen_base into the format needed by the
+	 * G15. This format places the pixels in a vertical rather than
+	 * horizontal format. Assuming a grid with 0,0 in the upper left corner
+	 * and 159,42 in the lower right corner, the first byte contains the
+	 * pixels 0,0 through 0,7 and the second byte contains the pixels 1,0
+	 * through 1,7. Within the byte, bit 0 represents 0,0; bit 1 0,1; etc.
+	 *
+	 * This loop operates in reverse to shift the lower bits into their
+	 * respective positions, shifting the lower rows into the higher bits.
+	 *
+	 * The offset is calculated for every 8 rows and is adjusted by 32 since
+	 * that is what the G15 image message expects.
+	 */
+
+	x = data->fb_info->var.xres;
+	y = data->fb_info->var.yres;
+	ll = data->fb_info->fix.line_length;
+
+	for (row = y-1; row >= 0; row--) {
+		offset = 32 + row/8 * x;
+		u = data->fb_vbitmap + offset;
+		/*
+		 * Iterate across the screen_base columns to get the
+		 * individual bits
+		 */
+		for (col = 0; col < ll; col++) {
+			/*
+			 * We will work with a temporary value since we don't
+			 * want to modify screen_base as we shift each bit
+			 * downward.
+			 */
+			temp = data->fb_bitmap[row * ll + col];
+
+			/*
+			 * For each bit in the pixel row we will shift it onto
+			 * the appropriate by by shift the g15 byte up by 1 and
+			 * simply doing a bitwise or of the low byte
+			 */
+			for (bit = 0; bit < 8; bit++) {
+				/*Shift the g15 byte up by 1 for this new row*/
+				u[bit] <<= 1;
+				/* Bring in the new pixel of temp */
+				u[bit] |= (temp & 0x01);
+				/*
+				 * Shift temp down so the low pixel is ready
+				 * for the next byte
+				 */
+				temp >>= 1;
+			}
+
+			/*
+			 * The last byte represented 8 vertical pixels so we'll
+			 * jump ahead 8
+			 */
+			u += 8;
+		}
+	}
+
+	/*
+	 * Now that we have translated screen_base into a format expected by
+	 * the g15 let's send out the vbitmap
+	 */
+	gfb_fb_send(data);
+
+}
+
+static void gfb_fb_update(struct gfb_data *data)
+{
+	switch (data->panel_type) {
+	case GFB_PANEL_TYPE_160_43_1:
+		gfb_fb_mono_update(data);
+		break;
+	case GFB_PANEL_TYPE_320_240_16:
+		gfb_fb_qvga_update(data);
+		break;
+	default:
+		break;
+	}
+}
+
+/* Callback from deferred IO workqueue */
+static void gfb_fb_deferred_io(struct fb_info *info, struct list_head *pagelist)
+{
+	gfb_fb_update(info->par);
+}
+
+/* Stub to call the system default and update the image on the gfb */
+static void gfb_fb_fillrect(struct fb_info *info,
+			    const struct fb_fillrect *rect)
+{
+	struct gfb_data *par = info->par;
+	sys_fillrect(info, rect);
+	gfb_fb_update(par);
+}
+
+/* Stub to call the system default and update the image on the gfb */
+static void gfb_fb_copyarea(struct fb_info *info,
+			    const struct fb_copyarea *area)
+{
+	struct gfb_data *par = info->par;
+	sys_copyarea(info, area);
+	gfb_fb_update(par);
+}
+
+/* Stub to call the system default and update the image on the gfb */
+static void gfb_fb_imageblit(struct fb_info *info, const struct fb_image *image)
+{
+	struct gfb_data *par = info->par;
+	sys_imageblit(info, image);
+	gfb_fb_update(par);
+}
+
+/*
+ * this is the slow path from userspace. they can seek and write to
+ * the fb. it's inefficient to do anything less than a full screen draw
+ */
+static ssize_t gfb_fb_write(struct fb_info *info, const char __user *buf,
+			    size_t count, loff_t *ppos)
+{
+	struct gfb_data *par = info->par;
+	ssize_t result;
+
+	result = fb_sys_write(info, buf, count, ppos);
+	if (result != -EFAULT && result != -EPERM)
+		gfb_fb_update(par);
+	return result;
+}
+
+static struct fb_ops gfb_ops = {
+	.owner = THIS_MODULE,
+	.fb_read = fb_sys_read,
+	.fb_write = gfb_fb_write,
+	.fb_fillrect  = gfb_fb_fillrect,
+	.fb_copyarea  = gfb_fb_copyarea,
+	.fb_imageblit = gfb_fb_imageblit,
+};
+
+/*
+ * The "fb_node" attribute
+ */
+static ssize_t gfb_fb_node_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf)
+{
+	unsigned fb_node;
+	struct gfb_data *data = dev_get_drvdata(dev);
+
+	fb_node = data->fb_info->node;
+
+	return sprintf(buf, "%u\n", fb_node);
+}
+EXPORT_SYMBOL(gfb_fb_node_show);
+
+/*
+ * The "fb_update_rate" attribute
+ */
+static ssize_t gfb_fb_update_rate_show(struct device *dev,
+				       struct device_attribute *attr,
+				       char *buf)
+{
+	unsigned fb_update_rate;
+	struct gfb_data *data = dev_get_drvdata(dev);
+
+	fb_update_rate = data->fb_update_rate;
+
+	return sprintf(buf, "%u\n", fb_update_rate);
+}
+EXPORT_SYMBOL(gfb_fb_update_rate_show);
+
+static ssize_t gfb_set_fb_update_rate(struct hid_device *hdev,
+				      unsigned fb_update_rate)
+{
+	struct gfb_data *data = hid_get_gfbdata(hdev);
+
+	if (fb_update_rate > GFB_UPDATE_RATE_LIMIT)
+		data->fb_update_rate = GFB_UPDATE_RATE_LIMIT;
+	else if (fb_update_rate == 0)
+		data->fb_update_rate = 1;
+	else
+		data->fb_update_rate = fb_update_rate;
+
+	data->fb_defio.delay = HZ / data->fb_update_rate;
+
+	return 0;
+}
+
+static ssize_t gfb_fb_update_rate_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count)
+{
+	struct hid_device *hdev;
+	int i;
+	unsigned u;
+	ssize_t set_result;
+
+	/* Get the hid associated with the device */
+	hdev = container_of(dev, struct hid_device, dev);
+
+	/* If we have an invalid pointer we'll return ENODATA */
+	if (hdev == NULL || &(hdev->dev) != dev)
+		return -ENODATA;
+
+	i = sscanf(buf, "%u", &u);
+	if (i != 1) {
+		dev_warn(dev, GFB_NAME " unrecognized input: %s", buf);
+		return -1;
+	}
+
+	set_result = gfb_set_fb_update_rate(hdev, u);
+
+	if (set_result < 0)
+		return set_result;
+
+	return count;
+}
+EXPORT_SYMBOL(gfb_fb_update_rate_store);
+
+static struct fb_deferred_io gfb_fb_defio = {
+	.delay = HZ / GFB_UPDATE_RATE_DEFAULT,
+	.deferred_io = gfb_fb_deferred_io,
+};
+
+static struct gfb_data *gfb_probe(struct hid_device *hdev,
+		     const int panel_type)
+{
+	int error;
+	struct gfb_data *data;
+
+	dev_dbg(&hdev->dev, "Logitech GamePanel framebuffer probe...");
+
+	/*
+	 * Let's allocate the gfb data structure, set some reasonable
+	 * defaults, and associate it with the device
+	 */
+	data = kzalloc(sizeof(struct gfb_data), GFP_KERNEL);
+	if (data == NULL) {
+		dev_err(&hdev->dev, "can't allocate space for Logitech GFB device attributes\n");
+		error = -ENOMEM;
+		goto err_no_cleanup;
+	}
+
+	data->fb_info = framebuffer_alloc(0, &hdev->dev);
+	if (data->fb_info == NULL) {
+		dev_err(&hdev->dev, GFB_NAME " failed to allocate a framebuffer\n");
+		goto err_cleanup_data;
+	}
+
+	/* init Framebuffer visual structures */
+
+	data->panel_type = panel_type;
+
+	switch (panel_type) {
+	case GFB_PANEL_TYPE_160_43_1:
+		data->fb_info->fix = (struct fb_fix_screeninfo) {
+			.id = "GFB_MONO",
+			.type = FB_TYPE_PACKED_PIXELS,
+			.visual = FB_VISUAL_MONO01,
+			.xpanstep = 0,
+			.ypanstep = 0,
+			.ywrapstep = 0,
+			.line_length = 32,
+			.accel = FB_ACCEL_NONE,
+		};
+		data->fb_info->var = (struct fb_var_screeninfo) {
+			.xres = 160,
+			.yres = 43,
+			.xres_virtual = 160,
+			.yres_virtual = 43,
+			.bits_per_pixel = 1,
+		};
+		data->vbitmap_size = 992;
+		break;
+	case GFB_PANEL_TYPE_320_240_16:
+		data->fb_info->fix = (struct fb_fix_screeninfo) {
+			.id = "GFB_QVGA",
+			.type = FB_TYPE_PACKED_PIXELS,
+			.visual = FB_VISUAL_TRUECOLOR,
+			.xpanstep = 0,
+			.ypanstep = 0,
+			.ywrapstep = 0,
+			.line_length = 640,
+			.accel = FB_ACCEL_NONE,
+		};
+		data->fb_info->var = (struct fb_var_screeninfo) {
+			.xres = 320,
+			.yres = 240,
+			.xres_virtual = 320,
+			.yres_virtual = 240,
+			.bits_per_pixel = 16,
+			.red        = {11, 5, 0}, /* RGB565 */
+			.green      = { 5, 6, 0},
+			.blue       = { 0, 5, 0},
+			.transp     = { 0, 0, 0},
+		};
+		data->vbitmap_size = 154112;
+		break;
+	default:
+		dev_err(&hdev->dev, GFB_NAME ": ERROR: unknown panel type\n");
+		goto err_cleanup_fb;
+	}
+
+	data->fb_info->fbops = &gfb_ops;
+	data->fb_info->fix.smem_len = data->fb_info->fix.line_length * data->fb_info->var.yres;
+	data->fb_info->par = data;
+	data->fb_info->flags = FBINFO_FLAG_DEFAULT;
+
+	spin_lock_init(&data->fb_urb_lock);
+
+	data->hdev = hdev;
+
+	data->fb_bitmap = vmalloc(data->fb_info->fix.smem_len);
+	if (data->fb_bitmap == NULL) {
+		dev_err(&hdev->dev, GFB_NAME ": ERROR: can't get a free page for framebuffer\n");
+		error = -ENOMEM;
+		goto err_cleanup_data;
+	}
+
+	data->fb_vbitmap = kmalloc(sizeof(u8) * data->vbitmap_size, GFP_KERNEL);
+	if (data->fb_vbitmap == NULL) {
+		dev_err(&hdev->dev, GFB_NAME ": ERROR: can't alloc vbitmap image buffer\n");
+		error = -ENOMEM;
+		goto err_cleanup_fb_bitmap;
+	}
+
+	data->fb_urb = usb_alloc_urb(0, GFP_KERNEL);
+	if (data->fb_urb == NULL) {
+		dev_err(&hdev->dev, GFB_NAME ": ERROR: can't alloc vbitmap image buffer\n");
+		error = -ENOMEM;
+		goto err_cleanup_fb_vbitmap;
+	}
+
+	data->fb_info->screen_base = (char __force __iomem *) data->fb_bitmap;
+
+	data->fb_update_rate = GFB_UPDATE_RATE_DEFAULT;
+
+	dbg_hid(KERN_INFO GFB_NAME " allocated framebuffer\n");
+
+	data->fb_defio = gfb_fb_defio;
+	data->fb_info->fbdefio = &data->fb_defio;
+
+	dbg_hid(KERN_INFO GFB_NAME " allocated deferred IO structure\n");
+
+	fb_deferred_io_init(data->fb_info);
+
+	if (register_framebuffer(data->fb_info) < 0)
+		goto err_cleanup_fb_urb;
+
+	return data;
+
+
+
+err_cleanup_fb_urb:
+	usb_free_urb(data->fb_urb);
+
+err_cleanup_fb_vbitmap:
+	kfree(data->fb_vbitmap);
+
+err_cleanup_fb_bitmap:
+	vfree(data->fb_bitmap);
+
+err_cleanup_fb:
+	framebuffer_release(data->fb_info);
+
+err_cleanup_data:
+	kfree(data);
+
+err_no_cleanup:
+
+
+	return 0;
+}
+EXPORT_SYMBOL(gfb_probe);
+
+static void gfb_remove(struct gfb_data *data)
+{
+	/* Clean up the framebuffer */
+	fb_deferred_io_cleanup(data->fb_info);
+	unregister_framebuffer(data->fb_info);
+	framebuffer_release(data->fb_info);
+	vfree(data->fb_bitmap);
+	kfree(data->fb_vbitmap);
+	usb_free_urb(data->fb_urb);
+}
+EXPORT_SYMBOL(gfb_remove);
+
+MODULE_DESCRIPTION("Logitech GFB HID Driver");
+MODULE_AUTHOR("Rick L Vinyard Jr (rvinyard@cs.nmsu.edu)");
+MODULE_AUTHOR("Alistair Buxton (a.j.buxton@gmail.com)");
+MODULE_LICENSE("GPL");
diff --git a/drivers/hid/hid-gfb.h b/drivers/hid/hid-gfb.h
new file mode 100644
index 0000000..31c3a95
--- /dev/null
+++ b/drivers/hid/hid-gfb.h
@@ -0,0 +1,37 @@
+#define GFB_PANEL_TYPE_160_43_1		0
+#define GFB_PANEL_TYPE_320_240_16	1
+
+/* Per device data structure */
+struct gfb_data {
+	struct hid_device *hdev;
+
+	/* Framebuffer stuff */
+	int panel_type;
+
+	int vbitmap_size;
+
+	u8 fb_update_rate;
+	u8 *fb_vbitmap;
+	u8 *fb_bitmap;
+	struct fb_info *fb_info;
+	struct fb_deferred_io fb_defio;
+	struct urb *fb_urb;
+	spinlock_t fb_urb_lock;
+};
+
+static ssize_t gfb_fb_node_show(struct device *dev,
+				struct device_attribute *attr,
+				char *buf);
+
+static ssize_t gfb_fb_update_rate_show(struct device *dev,
+				       struct device_attribute *attr,
+				       char *buf);
+
+static ssize_t gfb_fb_update_rate_store(struct device *dev,
+					struct device_attribute *attr,
+					const char *buf, size_t count);
+
+static struct gfb_data *gfb_probe(struct hid_device *hdev, const int panel_type);
+
+static void gfb_remove(struct gfb_data *data);
+
diff --git a/drivers/hid/hid-ids.h b/drivers/hid/hid-ids.h
index 31601ee..f6d0ce0 100644
--- a/drivers/hid/hid-ids.h
+++ b/drivers/hid/hid-ids.h
@@ -329,6 +329,9 @@
 #define USB_DEVICE_ID_LOGITECH_EXTREME_3D	0xc215
 #define USB_DEVICE_ID_LOGITECH_RUMBLEPAD2	0xc218
 #define USB_DEVICE_ID_LOGITECH_RUMBLEPAD2_2	0xc219
+#define USB_DEVICE_ID_LOGITECH_G13		0xc21c
+#define USB_DEVICE_ID_LOGITECH_G15_LCD		0xc222
+#define USB_DEVICE_ID_LOGITECH_G19_LCD		0xc229
 #define USB_DEVICE_ID_LOGITECH_WINGMAN_F3D	0xc283
 #define USB_DEVICE_ID_LOGITECH_FORCE3D_PRO	0xc286
 #define USB_DEVICE_ID_LOGITECH_FLIGHT_SYSTEM_G940	0xc287
-- 
1.7.0.4
