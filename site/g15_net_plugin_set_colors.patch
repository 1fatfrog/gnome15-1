### Eclipse Workspace Patch 1.0
#P g15daemon
Index: g15daemon/g15daemon.h
===================================================================
--- g15daemon/g15daemon.h	(revision 537)
+++ g15daemon/g15daemon.h	(working copy)
@@ -57,6 +57,10 @@
  * all M&G keys must be handled by the client.  If the client dies or exits, normal functions resume. */
 #define CLIENT_CMD_KEY_HANDLER 0x10
 
+/* Indicates the next buffer update will actually be 3 bytes for the RGB values of color keyboard backlights */
+#define CLIENT_CMD_KB_BACKLIGHT_COLOR 'r'
+
+
 enum {
     /* plugin types - LCD plugins are provided with a lcd_t and keystates via EVENT when visible */
 /* CORE plugins source and sink events, have no screen associated, and are not able to quit.
@@ -180,6 +184,9 @@
     unsigned int usr_foreground;
     /* set to 1 if screen is never to be user-selectable */
     unsigned int never_select;
+    /* set to 1 if the next buffer update will actually be updating the RGB values of the keyboard backlight (on color models) */
+    unsigned int expect_kb_backlight_color_update;
+    unsigned char rgb_buf[3];
     /* only used for plugins */
     plugin_t *g15plugin;
     
Index: plugins/g15_plugin_net.c
===================================================================
--- plugins/g15_plugin_net.c	(revision 537)
+++ plugins/g15_plugin_net.c	(working copy)
@@ -63,7 +63,17 @@
 
 static void process_client_cmds(lcdnode_t *lcdnode, int sock, unsigned int *msgbuf, unsigned int len)
 {
+    g15daemon_log(LOG_INFO, "Got OOB %d", msgbuf[0]);
 
+    if(lcdnode->lcd->expect_kb_backlight_color_update > 0) {
+    	lcdnode->lcd->rgb_buf[lcdnode->lcd->expect_kb_backlight_color_update - 1] = msgbuf[0];
+    	lcdnode->lcd->expect_kb_backlight_color_update++;
+    	if(lcdnode->lcd->expect_kb_backlight_color_update == 4) {
+    		g15daemon_log(LOG_INFO, "Setting RGB to %d,%d,%d", (unsigned int)lcdnode->lcd->rgb_buf[0],(unsigned int)lcdnode->lcd->rgb_buf[1],(unsigned int)lcdnode->lcd->rgb_buf[2]);
+    		setG510LEDColor((unsigned int)lcdnode->lcd->rgb_buf[0],(unsigned int)lcdnode->lcd->rgb_buf[1],(unsigned int)lcdnode->lcd->rgb_buf[2]);
+    		lcdnode->lcd->expect_kb_backlight_color_update = 0;
+    	}
+    }
     switch(msgbuf[0]){
     case CLIENT_CMD_SWITCH_PRIORITIES: {
         g15daemon_send_event(lcdnode,G15_EVENT_REQ_PRIORITY,1);
@@ -97,6 +107,13 @@
         send(sock,msgbuf,1,MSG_OOB);
         break;
     }
+    case CLIENT_CMD_KB_BACKLIGHT_COLOR: { /* next buffer update is actually RGB values for keyboard backlight */
+        pthread_mutex_lock(&lcdlist_mutex);
+        g15daemon_log(LOG_INFO, "Next buffer update is RGB for keyboard backlight");
+        lcdnode->lcd->expect_kb_backlight_color_update = 1;
+        pthread_mutex_unlock(&lcdlist_mutex);
+        break;
+    }
     default:
        if(msgbuf[0] & CLIENT_CMD_MKEY_LIGHTS)
        { /* client wants to change the M-key backlights */
